// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: inference/inference/params.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
	EpochParams           *EpochParams           `protobuf:"bytes,1,opt,name=epoch_params,json=epochParams,proto3" json:"epoch_params,omitempty"`
	ValidationParams      *ValidationParams      `protobuf:"bytes,2,opt,name=validation_params,json=validationParams,proto3" json:"validation_params,omitempty"`
	PocParams             *PocParams             `protobuf:"bytes,3,opt,name=poc_params,json=pocParams,proto3" json:"poc_params,omitempty"`
	TokenomicsParams      *TokenomicsParams      `protobuf:"bytes,4,opt,name=tokenomics_params,json=tokenomicsParams,proto3" json:"tokenomics_params,omitempty"`
	CollateralParams      *CollateralParams      `protobuf:"bytes,5,opt,name=collateral_params,json=collateralParams,proto3" json:"collateral_params,omitempty"`
	BitcoinRewardParams   *BitcoinRewardParams   `protobuf:"bytes,6,opt,name=bitcoin_reward_params,json=bitcoinRewardParams,proto3" json:"bitcoin_reward_params,omitempty"`
	DynamicPricingParams  *DynamicPricingParams  `protobuf:"bytes,7,opt,name=dynamic_pricing_params,json=dynamicPricingParams,proto3" json:"dynamic_pricing_params,omitempty"`
	BandwidthLimitsParams *BandwidthLimitsParams `protobuf:"bytes,8,opt,name=bandwidth_limits_params,json=bandwidthLimitsParams,proto3" json:"bandwidth_limits_params,omitempty"`
	ConfirmationPocParams *ConfirmationPoCParams `protobuf:"bytes,9,opt,name=confirmation_poc_params,json=confirmationPocParams,proto3" json:"confirmation_poc_params,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetEpochParams() *EpochParams {
	if m != nil {
		return m.EpochParams
	}
	return nil
}

func (m *Params) GetValidationParams() *ValidationParams {
	if m != nil {
		return m.ValidationParams
	}
	return nil
}

func (m *Params) GetPocParams() *PocParams {
	if m != nil {
		return m.PocParams
	}
	return nil
}

func (m *Params) GetTokenomicsParams() *TokenomicsParams {
	if m != nil {
		return m.TokenomicsParams
	}
	return nil
}

func (m *Params) GetCollateralParams() *CollateralParams {
	if m != nil {
		return m.CollateralParams
	}
	return nil
}

func (m *Params) GetBitcoinRewardParams() *BitcoinRewardParams {
	if m != nil {
		return m.BitcoinRewardParams
	}
	return nil
}

func (m *Params) GetDynamicPricingParams() *DynamicPricingParams {
	if m != nil {
		return m.DynamicPricingParams
	}
	return nil
}

func (m *Params) GetBandwidthLimitsParams() *BandwidthLimitsParams {
	if m != nil {
		return m.BandwidthLimitsParams
	}
	return nil
}

func (m *Params) GetConfirmationPocParams() *ConfirmationPoCParams {
	if m != nil {
		return m.ConfirmationPocParams
	}
	return nil
}

type GenesisOnlyParams struct {
	TotalSupply                             int64    `protobuf:"varint,1,opt,name=total_supply,json=totalSupply,proto3" json:"total_supply,omitempty"`
	OriginatorSupply                        int64    `protobuf:"varint,2,opt,name=originator_supply,json=originatorSupply,proto3" json:"originator_supply,omitempty"`
	TopRewardAmount                         int64    `protobuf:"varint,3,opt,name=top_reward_amount,json=topRewardAmount,proto3" json:"top_reward_amount,omitempty"`
	StandardRewardAmount                    int64    `protobuf:"varint,4,opt,name=standard_reward_amount,json=standardRewardAmount,proto3" json:"standard_reward_amount,omitempty"`
	PreProgrammedSaleAmount                 int64    `protobuf:"varint,5,opt,name=pre_programmed_sale_amount,json=preProgrammedSaleAmount,proto3" json:"pre_programmed_sale_amount,omitempty"`
	TopRewards                              int32    `protobuf:"varint,6,opt,name=top_rewards,json=topRewards,proto3" json:"top_rewards,omitempty"`
	SupplyDenom                             string   `protobuf:"bytes,7,opt,name=supply_denom,json=supplyDenom,proto3" json:"supply_denom,omitempty"`
	TopRewardPeriod                         int64    `protobuf:"varint,8,opt,name=top_reward_period,json=topRewardPeriod,proto3" json:"top_reward_period,omitempty"`
	TopRewardPayouts                        int64    `protobuf:"varint,9,opt,name=top_reward_payouts,json=topRewardPayouts,proto3" json:"top_reward_payouts,omitempty"`
	TopRewardPayoutsPerMiner                int64    `protobuf:"varint,10,opt,name=top_reward_payouts_per_miner,json=topRewardPayoutsPerMiner,proto3" json:"top_reward_payouts_per_miner,omitempty"`
	TopRewardMaxDuration                    int64    `protobuf:"varint,11,opt,name=top_reward_max_duration,json=topRewardMaxDuration,proto3" json:"top_reward_max_duration,omitempty"`
	MaxIndividualPowerPercentage            *Decimal `protobuf:"bytes,12,opt,name=max_individual_power_percentage,json=maxIndividualPowerPercentage,proto3" json:"max_individual_power_percentage,omitempty"`
	GenesisGuardianEnabled                  bool     `protobuf:"varint,13,opt,name=genesis_guardian_enabled,json=genesisGuardianEnabled,proto3" json:"genesis_guardian_enabled,omitempty"`
	GenesisGuardianNetworkMaturityThreshold int64    `protobuf:"varint,14,opt,name=genesis_guardian_network_maturity_threshold,json=genesisGuardianNetworkMaturityThreshold,proto3" json:"genesis_guardian_network_maturity_threshold,omitempty"`
	GenesisGuardianMultiplier               *Decimal `protobuf:"bytes,15,opt,name=genesis_guardian_multiplier,json=genesisGuardianMultiplier,proto3" json:"genesis_guardian_multiplier,omitempty"`
	GenesisGuardianAddresses                []string `protobuf:"bytes,16,rep,name=genesis_guardian_addresses,json=genesisGuardianAddresses,proto3" json:"genesis_guardian_addresses,omitempty"`
}

func (m *GenesisOnlyParams) Reset()         { *m = GenesisOnlyParams{} }
func (m *GenesisOnlyParams) String() string { return proto.CompactTextString(m) }
func (*GenesisOnlyParams) ProtoMessage()    {}
func (*GenesisOnlyParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{1}
}
func (m *GenesisOnlyParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisOnlyParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisOnlyParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisOnlyParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisOnlyParams.Merge(m, src)
}
func (m *GenesisOnlyParams) XXX_Size() int {
	return m.Size()
}
func (m *GenesisOnlyParams) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisOnlyParams.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisOnlyParams proto.InternalMessageInfo

func (m *GenesisOnlyParams) GetTotalSupply() int64 {
	if m != nil {
		return m.TotalSupply
	}
	return 0
}

func (m *GenesisOnlyParams) GetOriginatorSupply() int64 {
	if m != nil {
		return m.OriginatorSupply
	}
	return 0
}

func (m *GenesisOnlyParams) GetTopRewardAmount() int64 {
	if m != nil {
		return m.TopRewardAmount
	}
	return 0
}

func (m *GenesisOnlyParams) GetStandardRewardAmount() int64 {
	if m != nil {
		return m.StandardRewardAmount
	}
	return 0
}

func (m *GenesisOnlyParams) GetPreProgrammedSaleAmount() int64 {
	if m != nil {
		return m.PreProgrammedSaleAmount
	}
	return 0
}

func (m *GenesisOnlyParams) GetTopRewards() int32 {
	if m != nil {
		return m.TopRewards
	}
	return 0
}

func (m *GenesisOnlyParams) GetSupplyDenom() string {
	if m != nil {
		return m.SupplyDenom
	}
	return ""
}

func (m *GenesisOnlyParams) GetTopRewardPeriod() int64 {
	if m != nil {
		return m.TopRewardPeriod
	}
	return 0
}

func (m *GenesisOnlyParams) GetTopRewardPayouts() int64 {
	if m != nil {
		return m.TopRewardPayouts
	}
	return 0
}

func (m *GenesisOnlyParams) GetTopRewardPayoutsPerMiner() int64 {
	if m != nil {
		return m.TopRewardPayoutsPerMiner
	}
	return 0
}

func (m *GenesisOnlyParams) GetTopRewardMaxDuration() int64 {
	if m != nil {
		return m.TopRewardMaxDuration
	}
	return 0
}

func (m *GenesisOnlyParams) GetMaxIndividualPowerPercentage() *Decimal {
	if m != nil {
		return m.MaxIndividualPowerPercentage
	}
	return nil
}

func (m *GenesisOnlyParams) GetGenesisGuardianEnabled() bool {
	if m != nil {
		return m.GenesisGuardianEnabled
	}
	return false
}

func (m *GenesisOnlyParams) GetGenesisGuardianNetworkMaturityThreshold() int64 {
	if m != nil {
		return m.GenesisGuardianNetworkMaturityThreshold
	}
	return 0
}

func (m *GenesisOnlyParams) GetGenesisGuardianMultiplier() *Decimal {
	if m != nil {
		return m.GenesisGuardianMultiplier
	}
	return nil
}

func (m *GenesisOnlyParams) GetGenesisGuardianAddresses() []string {
	if m != nil {
		return m.GenesisGuardianAddresses
	}
	return nil
}

type TokenomicsParams struct {
	SubsidyReductionInterval *Decimal `protobuf:"bytes,1,opt,name=subsidy_reduction_interval,json=subsidyReductionInterval,proto3" json:"subsidy_reduction_interval,omitempty"`
	SubsidyReductionAmount   *Decimal `protobuf:"bytes,2,opt,name=subsidy_reduction_amount,json=subsidyReductionAmount,proto3" json:"subsidy_reduction_amount,omitempty"`
	CurrentSubsidyPercentage *Decimal `protobuf:"bytes,3,opt,name=current_subsidy_percentage,json=currentSubsidyPercentage,proto3" json:"current_subsidy_percentage,omitempty"`
	TopRewardAllowedFailure  *Decimal `protobuf:"bytes,4,opt,name=top_reward_allowed_failure,json=topRewardAllowedFailure,proto3" json:"top_reward_allowed_failure,omitempty"`
	TopMinerPocQualification int64    `protobuf:"varint,5,opt,name=top_miner_poc_qualification,json=topMinerPocQualification,proto3" json:"top_miner_poc_qualification,omitempty"`
	WorkVestingPeriod        uint64   `protobuf:"varint,6,opt,name=work_vesting_period,json=workVestingPeriod,proto3" json:"work_vesting_period,omitempty"`
	RewardVestingPeriod      uint64   `protobuf:"varint,7,opt,name=reward_vesting_period,json=rewardVestingPeriod,proto3" json:"reward_vesting_period,omitempty"`
	TopMinerVestingPeriod    uint64   `protobuf:"varint,8,opt,name=top_miner_vesting_period,json=topMinerVestingPeriod,proto3" json:"top_miner_vesting_period,omitempty"`
}

func (m *TokenomicsParams) Reset()         { *m = TokenomicsParams{} }
func (m *TokenomicsParams) String() string { return proto.CompactTextString(m) }
func (*TokenomicsParams) ProtoMessage()    {}
func (*TokenomicsParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{2}
}
func (m *TokenomicsParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenomicsParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenomicsParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenomicsParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenomicsParams.Merge(m, src)
}
func (m *TokenomicsParams) XXX_Size() int {
	return m.Size()
}
func (m *TokenomicsParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenomicsParams.DiscardUnknown(m)
}

var xxx_messageInfo_TokenomicsParams proto.InternalMessageInfo

func (m *TokenomicsParams) GetSubsidyReductionInterval() *Decimal {
	if m != nil {
		return m.SubsidyReductionInterval
	}
	return nil
}

func (m *TokenomicsParams) GetSubsidyReductionAmount() *Decimal {
	if m != nil {
		return m.SubsidyReductionAmount
	}
	return nil
}

func (m *TokenomicsParams) GetCurrentSubsidyPercentage() *Decimal {
	if m != nil {
		return m.CurrentSubsidyPercentage
	}
	return nil
}

func (m *TokenomicsParams) GetTopRewardAllowedFailure() *Decimal {
	if m != nil {
		return m.TopRewardAllowedFailure
	}
	return nil
}

func (m *TokenomicsParams) GetTopMinerPocQualification() int64 {
	if m != nil {
		return m.TopMinerPocQualification
	}
	return 0
}

func (m *TokenomicsParams) GetWorkVestingPeriod() uint64 {
	if m != nil {
		return m.WorkVestingPeriod
	}
	return 0
}

func (m *TokenomicsParams) GetRewardVestingPeriod() uint64 {
	if m != nil {
		return m.RewardVestingPeriod
	}
	return 0
}

func (m *TokenomicsParams) GetTopMinerVestingPeriod() uint64 {
	if m != nil {
		return m.TopMinerVestingPeriod
	}
	return 0
}

type EpochParams struct {
	EpochLength                    int64    `protobuf:"varint,1,opt,name=epoch_length,json=epochLength,proto3" json:"epoch_length,omitempty"`
	EpochMultiplier                int64    `protobuf:"varint,2,opt,name=epoch_multiplier,json=epochMultiplier,proto3" json:"epoch_multiplier,omitempty"`
	EpochShift                     int64    `protobuf:"varint,3,opt,name=epoch_shift,json=epochShift,proto3" json:"epoch_shift,omitempty"`
	DefaultUnitOfComputePrice      int64    `protobuf:"varint,4,opt,name=default_unit_of_compute_price,json=defaultUnitOfComputePrice,proto3" json:"default_unit_of_compute_price,omitempty"`
	PocStageDuration               int64    `protobuf:"varint,5,opt,name=poc_stage_duration,json=pocStageDuration,proto3" json:"poc_stage_duration,omitempty"`
	PocExchangeDuration            int64    `protobuf:"varint,6,opt,name=poc_exchange_duration,json=pocExchangeDuration,proto3" json:"poc_exchange_duration,omitempty"`
	PocValidationDelay             int64    `protobuf:"varint,7,opt,name=poc_validation_delay,json=pocValidationDelay,proto3" json:"poc_validation_delay,omitempty"`
	PocValidationDuration          int64    `protobuf:"varint,8,opt,name=poc_validation_duration,json=pocValidationDuration,proto3" json:"poc_validation_duration,omitempty"`
	SetNewValidatorsDelay          int64    `protobuf:"varint,9,opt,name=set_new_validators_delay,json=setNewValidatorsDelay,proto3" json:"set_new_validators_delay,omitempty"`
	InferenceValidationCutoff      int64    `protobuf:"varint,10,opt,name=inference_validation_cutoff,json=inferenceValidationCutoff,proto3" json:"inference_validation_cutoff,omitempty"`
	InferencePruningEpochThreshold uint64   `protobuf:"varint,11,opt,name=inference_pruning_epoch_threshold,json=inferencePruningEpochThreshold,proto3" json:"inference_pruning_epoch_threshold,omitempty"`
	InferencePruningMax            int64    `protobuf:"varint,12,opt,name=inference_pruning_max,json=inferencePruningMax,proto3" json:"inference_pruning_max,omitempty"`
	PocPruningMax                  int64    `protobuf:"varint,13,opt,name=poc_pruning_max,json=pocPruningMax,proto3" json:"poc_pruning_max,omitempty"`
	PocSlotAllocation              *Decimal `protobuf:"bytes,14,opt,name=poc_slot_allocation,json=pocSlotAllocation,proto3" json:"poc_slot_allocation,omitempty"`
}

func (m *EpochParams) Reset()         { *m = EpochParams{} }
func (m *EpochParams) String() string { return proto.CompactTextString(m) }
func (*EpochParams) ProtoMessage()    {}
func (*EpochParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{3}
}
func (m *EpochParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochParams.Merge(m, src)
}
func (m *EpochParams) XXX_Size() int {
	return m.Size()
}
func (m *EpochParams) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochParams.DiscardUnknown(m)
}

var xxx_messageInfo_EpochParams proto.InternalMessageInfo

func (m *EpochParams) GetEpochLength() int64 {
	if m != nil {
		return m.EpochLength
	}
	return 0
}

func (m *EpochParams) GetEpochMultiplier() int64 {
	if m != nil {
		return m.EpochMultiplier
	}
	return 0
}

func (m *EpochParams) GetEpochShift() int64 {
	if m != nil {
		return m.EpochShift
	}
	return 0
}

func (m *EpochParams) GetDefaultUnitOfComputePrice() int64 {
	if m != nil {
		return m.DefaultUnitOfComputePrice
	}
	return 0
}

func (m *EpochParams) GetPocStageDuration() int64 {
	if m != nil {
		return m.PocStageDuration
	}
	return 0
}

func (m *EpochParams) GetPocExchangeDuration() int64 {
	if m != nil {
		return m.PocExchangeDuration
	}
	return 0
}

func (m *EpochParams) GetPocValidationDelay() int64 {
	if m != nil {
		return m.PocValidationDelay
	}
	return 0
}

func (m *EpochParams) GetPocValidationDuration() int64 {
	if m != nil {
		return m.PocValidationDuration
	}
	return 0
}

func (m *EpochParams) GetSetNewValidatorsDelay() int64 {
	if m != nil {
		return m.SetNewValidatorsDelay
	}
	return 0
}

func (m *EpochParams) GetInferenceValidationCutoff() int64 {
	if m != nil {
		return m.InferenceValidationCutoff
	}
	return 0
}

func (m *EpochParams) GetInferencePruningEpochThreshold() uint64 {
	if m != nil {
		return m.InferencePruningEpochThreshold
	}
	return 0
}

func (m *EpochParams) GetInferencePruningMax() int64 {
	if m != nil {
		return m.InferencePruningMax
	}
	return 0
}

func (m *EpochParams) GetPocPruningMax() int64 {
	if m != nil {
		return m.PocPruningMax
	}
	return 0
}

func (m *EpochParams) GetPocSlotAllocation() *Decimal {
	if m != nil {
		return m.PocSlotAllocation
	}
	return nil
}

type ValidationParams struct {
	FalsePositiveRate              *Decimal `protobuf:"bytes,1,opt,name=false_positive_rate,json=falsePositiveRate,proto3" json:"false_positive_rate,omitempty"`
	MinRampUpMeasurements          int32    `protobuf:"varint,2,opt,name=min_ramp_up_measurements,json=minRampUpMeasurements,proto3" json:"min_ramp_up_measurements,omitempty"`
	PassValue                      *Decimal `protobuf:"bytes,3,opt,name=pass_value,json=passValue,proto3" json:"pass_value,omitempty"`
	MinValidationAverage           *Decimal `protobuf:"bytes,4,opt,name=min_validation_average,json=minValidationAverage,proto3" json:"min_validation_average,omitempty"`
	MaxValidationAverage           *Decimal `protobuf:"bytes,5,opt,name=max_validation_average,json=maxValidationAverage,proto3" json:"max_validation_average,omitempty"`
	ExpirationBlocks               int64    `protobuf:"varint,6,opt,name=expiration_blocks,json=expirationBlocks,proto3" json:"expiration_blocks,omitempty"`
	EpochsToMax                    int64    `protobuf:"varint,7,opt,name=epochs_to_max,json=epochsToMax,proto3" json:"epochs_to_max,omitempty"`
	FullValidationTrafficCutoff    int64    `protobuf:"varint,8,opt,name=full_validation_traffic_cutoff,json=fullValidationTrafficCutoff,proto3" json:"full_validation_traffic_cutoff,omitempty"`
	MinValidationHalfway           *Decimal `protobuf:"bytes,9,opt,name=min_validation_halfway,json=minValidationHalfway,proto3" json:"min_validation_halfway,omitempty"`
	MinValidationTrafficCutoff     int64    `protobuf:"varint,10,opt,name=min_validation_traffic_cutoff,json=minValidationTrafficCutoff,proto3" json:"min_validation_traffic_cutoff,omitempty"`
	MissPercentageCutoff           *Decimal `protobuf:"bytes,11,opt,name=miss_percentage_cutoff,json=missPercentageCutoff,proto3" json:"miss_percentage_cutoff,omitempty"`
	MissRequestsPenalty            *Decimal `protobuf:"bytes,12,opt,name=miss_requests_penalty,json=missRequestsPenalty,proto3" json:"miss_requests_penalty,omitempty"`
	TimestampExpiration            int64    `protobuf:"varint,13,opt,name=timestamp_expiration,json=timestampExpiration,proto3" json:"timestamp_expiration,omitempty"`
	TimestampAdvance               int64    `protobuf:"varint,14,opt,name=timestamp_advance,json=timestampAdvance,proto3" json:"timestamp_advance,omitempty"`
	EstimatedLimitsPerBlockKb      uint64   `protobuf:"varint,15,opt,name=estimated_limits_per_block_kb,json=estimatedLimitsPerBlockKb,proto3" json:"estimated_limits_per_block_kb,omitempty"`
	InvalidReputationPreserve      *Decimal `protobuf:"bytes,16,opt,name=invalid_reputation_preserve,json=invalidReputationPreserve,proto3" json:"invalid_reputation_preserve,omitempty"`
	BadParticipantInvalidationRate *Decimal `protobuf:"bytes,17,opt,name=bad_participant_invalidation_rate,json=badParticipantInvalidationRate,proto3" json:"bad_participant_invalidation_rate,omitempty"`
	InvalidationHThreshold         *Decimal `protobuf:"bytes,18,opt,name=invalidation_h_threshold,json=invalidationHThreshold,proto3" json:"invalidation_h_threshold,omitempty"`
	DowntimeGoodPercentage         *Decimal `protobuf:"bytes,19,opt,name=downtime_good_percentage,json=downtimeGoodPercentage,proto3" json:"downtime_good_percentage,omitempty"`
	DowntimeBadPercentage          *Decimal `protobuf:"bytes,20,opt,name=downtime_bad_percentage,json=downtimeBadPercentage,proto3" json:"downtime_bad_percentage,omitempty"`
	DowntimeHThreshold             *Decimal `protobuf:"bytes,21,opt,name=downtime_h_threshold,json=downtimeHThreshold,proto3" json:"downtime_h_threshold,omitempty"`
	DowntimeReputationPreserve     *Decimal `protobuf:"bytes,22,opt,name=downtime_reputation_preserve,json=downtimeReputationPreserve,proto3" json:"downtime_reputation_preserve,omitempty"`
	QuickFailureThreshold          *Decimal `protobuf:"bytes,23,opt,name=quick_failure_threshold,json=quickFailureThreshold,proto3" json:"quick_failure_threshold,omitempty"`
	BinomTestP0                    *Decimal `protobuf:"bytes,24,opt,name=binom_test_p0,json=binomTestP0,proto3" json:"binom_test_p0,omitempty"`
}

func (m *ValidationParams) Reset()         { *m = ValidationParams{} }
func (m *ValidationParams) String() string { return proto.CompactTextString(m) }
func (*ValidationParams) ProtoMessage()    {}
func (*ValidationParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{4}
}
func (m *ValidationParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidationParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidationParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidationParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidationParams.Merge(m, src)
}
func (m *ValidationParams) XXX_Size() int {
	return m.Size()
}
func (m *ValidationParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidationParams.DiscardUnknown(m)
}

var xxx_messageInfo_ValidationParams proto.InternalMessageInfo

func (m *ValidationParams) GetFalsePositiveRate() *Decimal {
	if m != nil {
		return m.FalsePositiveRate
	}
	return nil
}

func (m *ValidationParams) GetMinRampUpMeasurements() int32 {
	if m != nil {
		return m.MinRampUpMeasurements
	}
	return 0
}

func (m *ValidationParams) GetPassValue() *Decimal {
	if m != nil {
		return m.PassValue
	}
	return nil
}

func (m *ValidationParams) GetMinValidationAverage() *Decimal {
	if m != nil {
		return m.MinValidationAverage
	}
	return nil
}

func (m *ValidationParams) GetMaxValidationAverage() *Decimal {
	if m != nil {
		return m.MaxValidationAverage
	}
	return nil
}

func (m *ValidationParams) GetExpirationBlocks() int64 {
	if m != nil {
		return m.ExpirationBlocks
	}
	return 0
}

func (m *ValidationParams) GetEpochsToMax() int64 {
	if m != nil {
		return m.EpochsToMax
	}
	return 0
}

func (m *ValidationParams) GetFullValidationTrafficCutoff() int64 {
	if m != nil {
		return m.FullValidationTrafficCutoff
	}
	return 0
}

func (m *ValidationParams) GetMinValidationHalfway() *Decimal {
	if m != nil {
		return m.MinValidationHalfway
	}
	return nil
}

func (m *ValidationParams) GetMinValidationTrafficCutoff() int64 {
	if m != nil {
		return m.MinValidationTrafficCutoff
	}
	return 0
}

func (m *ValidationParams) GetMissPercentageCutoff() *Decimal {
	if m != nil {
		return m.MissPercentageCutoff
	}
	return nil
}

func (m *ValidationParams) GetMissRequestsPenalty() *Decimal {
	if m != nil {
		return m.MissRequestsPenalty
	}
	return nil
}

func (m *ValidationParams) GetTimestampExpiration() int64 {
	if m != nil {
		return m.TimestampExpiration
	}
	return 0
}

func (m *ValidationParams) GetTimestampAdvance() int64 {
	if m != nil {
		return m.TimestampAdvance
	}
	return 0
}

func (m *ValidationParams) GetEstimatedLimitsPerBlockKb() uint64 {
	if m != nil {
		return m.EstimatedLimitsPerBlockKb
	}
	return 0
}

func (m *ValidationParams) GetInvalidReputationPreserve() *Decimal {
	if m != nil {
		return m.InvalidReputationPreserve
	}
	return nil
}

func (m *ValidationParams) GetBadParticipantInvalidationRate() *Decimal {
	if m != nil {
		return m.BadParticipantInvalidationRate
	}
	return nil
}

func (m *ValidationParams) GetInvalidationHThreshold() *Decimal {
	if m != nil {
		return m.InvalidationHThreshold
	}
	return nil
}

func (m *ValidationParams) GetDowntimeGoodPercentage() *Decimal {
	if m != nil {
		return m.DowntimeGoodPercentage
	}
	return nil
}

func (m *ValidationParams) GetDowntimeBadPercentage() *Decimal {
	if m != nil {
		return m.DowntimeBadPercentage
	}
	return nil
}

func (m *ValidationParams) GetDowntimeHThreshold() *Decimal {
	if m != nil {
		return m.DowntimeHThreshold
	}
	return nil
}

func (m *ValidationParams) GetDowntimeReputationPreserve() *Decimal {
	if m != nil {
		return m.DowntimeReputationPreserve
	}
	return nil
}

func (m *ValidationParams) GetQuickFailureThreshold() *Decimal {
	if m != nil {
		return m.QuickFailureThreshold
	}
	return nil
}

func (m *ValidationParams) GetBinomTestP0() *Decimal {
	if m != nil {
		return m.BinomTestP0
	}
	return nil
}

type PoCModelParams struct {
	Dim              int32    `protobuf:"varint,1,opt,name=dim,proto3" json:"dim,omitempty"`
	NLayers          int32    `protobuf:"varint,2,opt,name=n_layers,json=nLayers,proto3" json:"n_layers,omitempty"`
	NHeads           int32    `protobuf:"varint,3,opt,name=n_heads,json=nHeads,proto3" json:"n_heads,omitempty"`
	NKvHeads         int32    `protobuf:"varint,4,opt,name=n_kv_heads,json=nKvHeads,proto3" json:"n_kv_heads,omitempty"`
	VocabSize        int32    `protobuf:"varint,5,opt,name=vocab_size,json=vocabSize,proto3" json:"vocab_size,omitempty"`
	FfnDimMultiplier *Decimal `protobuf:"bytes,6,opt,name=ffn_dim_multiplier,json=ffnDimMultiplier,proto3" json:"ffn_dim_multiplier,omitempty"`
	MultipleOf       int32    `protobuf:"varint,7,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	NormEps          *Decimal `protobuf:"bytes,8,opt,name=norm_eps,json=normEps,proto3" json:"norm_eps,omitempty"`
	RopeTheta        int32    `protobuf:"varint,9,opt,name=rope_theta,json=ropeTheta,proto3" json:"rope_theta,omitempty"`
	UseScaledRope    bool     `protobuf:"varint,10,opt,name=use_scaled_rope,json=useScaledRope,proto3" json:"use_scaled_rope,omitempty"`
	SeqLen           int32    `protobuf:"varint,11,opt,name=seq_len,json=seqLen,proto3" json:"seq_len,omitempty"`
	RTarget          *Decimal `protobuf:"bytes,12,opt,name=r_target,json=rTarget,proto3" json:"r_target,omitempty"`
}

func (m *PoCModelParams) Reset()         { *m = PoCModelParams{} }
func (m *PoCModelParams) String() string { return proto.CompactTextString(m) }
func (*PoCModelParams) ProtoMessage()    {}
func (*PoCModelParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{5}
}
func (m *PoCModelParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoCModelParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoCModelParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoCModelParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoCModelParams.Merge(m, src)
}
func (m *PoCModelParams) XXX_Size() int {
	return m.Size()
}
func (m *PoCModelParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PoCModelParams.DiscardUnknown(m)
}

var xxx_messageInfo_PoCModelParams proto.InternalMessageInfo

func (m *PoCModelParams) GetDim() int32 {
	if m != nil {
		return m.Dim
	}
	return 0
}

func (m *PoCModelParams) GetNLayers() int32 {
	if m != nil {
		return m.NLayers
	}
	return 0
}

func (m *PoCModelParams) GetNHeads() int32 {
	if m != nil {
		return m.NHeads
	}
	return 0
}

func (m *PoCModelParams) GetNKvHeads() int32 {
	if m != nil {
		return m.NKvHeads
	}
	return 0
}

func (m *PoCModelParams) GetVocabSize() int32 {
	if m != nil {
		return m.VocabSize
	}
	return 0
}

func (m *PoCModelParams) GetFfnDimMultiplier() *Decimal {
	if m != nil {
		return m.FfnDimMultiplier
	}
	return nil
}

func (m *PoCModelParams) GetMultipleOf() int32 {
	if m != nil {
		return m.MultipleOf
	}
	return 0
}

func (m *PoCModelParams) GetNormEps() *Decimal {
	if m != nil {
		return m.NormEps
	}
	return nil
}

func (m *PoCModelParams) GetRopeTheta() int32 {
	if m != nil {
		return m.RopeTheta
	}
	return 0
}

func (m *PoCModelParams) GetUseScaledRope() bool {
	if m != nil {
		return m.UseScaledRope
	}
	return false
}

func (m *PoCModelParams) GetSeqLen() int32 {
	if m != nil {
		return m.SeqLen
	}
	return 0
}

func (m *PoCModelParams) GetRTarget() *Decimal {
	if m != nil {
		return m.RTarget
	}
	return nil
}

type PocParams struct {
	DefaultDifficulty            int32           `protobuf:"varint,1,opt,name=default_difficulty,json=defaultDifficulty,proto3" json:"default_difficulty,omitempty"`
	ValidationSampleSize         int32           `protobuf:"varint,2,opt,name=validation_sample_size,json=validationSampleSize,proto3" json:"validation_sample_size,omitempty"`
	PocDataPruningEpochThreshold uint64          `protobuf:"varint,3,opt,name=poc_data_pruning_epoch_threshold,json=pocDataPruningEpochThreshold,proto3" json:"poc_data_pruning_epoch_threshold,omitempty"`
	WeightScaleFactor            *Decimal        `protobuf:"bytes,4,opt,name=weight_scale_factor,json=weightScaleFactor,proto3" json:"weight_scale_factor,omitempty"`
	ModelParams                  *PoCModelParams `protobuf:"bytes,5,opt,name=model_params,json=modelParams,proto3" json:"model_params,omitempty"`
}

func (m *PocParams) Reset()         { *m = PocParams{} }
func (m *PocParams) String() string { return proto.CompactTextString(m) }
func (*PocParams) ProtoMessage()    {}
func (*PocParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{6}
}
func (m *PocParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PocParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PocParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PocParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PocParams.Merge(m, src)
}
func (m *PocParams) XXX_Size() int {
	return m.Size()
}
func (m *PocParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PocParams.DiscardUnknown(m)
}

var xxx_messageInfo_PocParams proto.InternalMessageInfo

func (m *PocParams) GetDefaultDifficulty() int32 {
	if m != nil {
		return m.DefaultDifficulty
	}
	return 0
}

func (m *PocParams) GetValidationSampleSize() int32 {
	if m != nil {
		return m.ValidationSampleSize
	}
	return 0
}

func (m *PocParams) GetPocDataPruningEpochThreshold() uint64 {
	if m != nil {
		return m.PocDataPruningEpochThreshold
	}
	return 0
}

func (m *PocParams) GetWeightScaleFactor() *Decimal {
	if m != nil {
		return m.WeightScaleFactor
	}
	return nil
}

func (m *PocParams) GetModelParams() *PoCModelParams {
	if m != nil {
		return m.ModelParams
	}
	return nil
}

type Decimal struct {
	Value    int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Exponent int32 `protobuf:"varint,2,opt,name=exponent,proto3" json:"exponent,omitempty"`
}

func (m *Decimal) Reset()         { *m = Decimal{} }
func (m *Decimal) String() string { return proto.CompactTextString(m) }
func (*Decimal) ProtoMessage()    {}
func (*Decimal) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{7}
}
func (m *Decimal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal.Merge(m, src)
}
func (m *Decimal) XXX_Size() int {
	return m.Size()
}
func (m *Decimal) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal proto.InternalMessageInfo

func (m *Decimal) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Decimal) GetExponent() int32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

// CollateralParams defines the parameters for collateral slashing.
type CollateralParams struct {
	// slash_fraction_invalid is the percentage of collateral to slash when a participant is marked INVALID.
	SlashFractionInvalid *Decimal `protobuf:"bytes,1,opt,name=slash_fraction_invalid,json=slashFractionInvalid,proto3" json:"slash_fraction_invalid,omitempty"`
	// slash_fraction_downtime is the percentage of collateral to slash for downtime.
	SlashFractionDowntime *Decimal `protobuf:"bytes,2,opt,name=slash_fraction_downtime,json=slashFractionDowntime,proto3" json:"slash_fraction_downtime,omitempty"`
	// downtime_missed_percentage_threshold is the missed request percentage that triggers a downtime slash.
	DowntimeMissedPercentageThreshold *Decimal `protobuf:"bytes,3,opt,name=downtime_missed_percentage_threshold,json=downtimeMissedPercentageThreshold,proto3" json:"downtime_missed_percentage_threshold,omitempty"`
	GracePeriodEndEpoch               uint64   `protobuf:"varint,4,opt,name=grace_period_end_epoch,json=gracePeriodEndEpoch,proto3" json:"grace_period_end_epoch,omitempty"`
	// BaseWeightRatio is the portion of potential weight granted unconditionally (0-1)
	BaseWeightRatio *Decimal `protobuf:"bytes,5,opt,name=base_weight_ratio,json=baseWeightRatio,proto3" json:"base_weight_ratio,omitempty"`
	// CollateralPerWeightUnit is the amount of collateral required per unit of weight
	CollateralPerWeightUnit *Decimal `protobuf:"bytes,6,opt,name=collateral_per_weight_unit,json=collateralPerWeightUnit,proto3" json:"collateral_per_weight_unit,omitempty"`
}

func (m *CollateralParams) Reset()         { *m = CollateralParams{} }
func (m *CollateralParams) String() string { return proto.CompactTextString(m) }
func (*CollateralParams) ProtoMessage()    {}
func (*CollateralParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{8}
}
func (m *CollateralParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollateralParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollateralParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollateralParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollateralParams.Merge(m, src)
}
func (m *CollateralParams) XXX_Size() int {
	return m.Size()
}
func (m *CollateralParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CollateralParams.DiscardUnknown(m)
}

var xxx_messageInfo_CollateralParams proto.InternalMessageInfo

func (m *CollateralParams) GetSlashFractionInvalid() *Decimal {
	if m != nil {
		return m.SlashFractionInvalid
	}
	return nil
}

func (m *CollateralParams) GetSlashFractionDowntime() *Decimal {
	if m != nil {
		return m.SlashFractionDowntime
	}
	return nil
}

func (m *CollateralParams) GetDowntimeMissedPercentageThreshold() *Decimal {
	if m != nil {
		return m.DowntimeMissedPercentageThreshold
	}
	return nil
}

func (m *CollateralParams) GetGracePeriodEndEpoch() uint64 {
	if m != nil {
		return m.GracePeriodEndEpoch
	}
	return 0
}

func (m *CollateralParams) GetBaseWeightRatio() *Decimal {
	if m != nil {
		return m.BaseWeightRatio
	}
	return nil
}

func (m *CollateralParams) GetCollateralPerWeightUnit() *Decimal {
	if m != nil {
		return m.CollateralPerWeightUnit
	}
	return nil
}

// BitcoinRewardParams defines the parameters for Bitcoin-style reward system.
type BitcoinRewardParams struct {
	// use_bitcoin_rewards enables/disables the Bitcoin-style reward system (default: true for production, false for safe deployment)
	UseBitcoinRewards bool `protobuf:"varint,1,opt,name=use_bitcoin_rewards,json=useBitcoinRewards,proto3" json:"use_bitcoin_rewards,omitempty"`
	// initial_epoch_reward is the base reward amount per epoch (in native tokens)
	InitialEpochReward uint64 `protobuf:"varint,2,opt,name=initial_epoch_reward,json=initialEpochReward,proto3" json:"initial_epoch_reward,omitempty"`
	// decay_rate is the exponential decay rate per epoch for reward halving
	DecayRate *Decimal `protobuf:"bytes,3,opt,name=decay_rate,json=decayRate,proto3" json:"decay_rate,omitempty"`
	// genesis_epoch is the starting epoch for Bitcoin-style calculations
	GenesisEpoch uint64 `protobuf:"varint,4,opt,name=genesis_epoch,json=genesisEpoch,proto3" json:"genesis_epoch,omitempty"`
	// utilization_bonus_factor controls bonus multipliers for high-demand models (Phase 2)
	UtilizationBonusFactor *Decimal `protobuf:"bytes,5,opt,name=utilization_bonus_factor,json=utilizationBonusFactor,proto3" json:"utilization_bonus_factor,omitempty"`
	// full_coverage_bonus_factor is the multiplier for participants supporting all governance models (Phase 2)
	FullCoverageBonusFactor *Decimal `protobuf:"bytes,6,opt,name=full_coverage_bonus_factor,json=fullCoverageBonusFactor,proto3" json:"full_coverage_bonus_factor,omitempty"`
	// partial_coverage_bonus_factor is the scaling factor for partial model coverage (Phase 2)
	PartialCoverageBonusFactor *Decimal `protobuf:"bytes,7,opt,name=partial_coverage_bonus_factor,json=partialCoverageBonusFactor,proto3" json:"partial_coverage_bonus_factor,omitempty"`
}

func (m *BitcoinRewardParams) Reset()         { *m = BitcoinRewardParams{} }
func (m *BitcoinRewardParams) String() string { return proto.CompactTextString(m) }
func (*BitcoinRewardParams) ProtoMessage()    {}
func (*BitcoinRewardParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{9}
}
func (m *BitcoinRewardParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BitcoinRewardParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BitcoinRewardParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BitcoinRewardParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BitcoinRewardParams.Merge(m, src)
}
func (m *BitcoinRewardParams) XXX_Size() int {
	return m.Size()
}
func (m *BitcoinRewardParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BitcoinRewardParams.DiscardUnknown(m)
}

var xxx_messageInfo_BitcoinRewardParams proto.InternalMessageInfo

func (m *BitcoinRewardParams) GetUseBitcoinRewards() bool {
	if m != nil {
		return m.UseBitcoinRewards
	}
	return false
}

func (m *BitcoinRewardParams) GetInitialEpochReward() uint64 {
	if m != nil {
		return m.InitialEpochReward
	}
	return 0
}

func (m *BitcoinRewardParams) GetDecayRate() *Decimal {
	if m != nil {
		return m.DecayRate
	}
	return nil
}

func (m *BitcoinRewardParams) GetGenesisEpoch() uint64 {
	if m != nil {
		return m.GenesisEpoch
	}
	return 0
}

func (m *BitcoinRewardParams) GetUtilizationBonusFactor() *Decimal {
	if m != nil {
		return m.UtilizationBonusFactor
	}
	return nil
}

func (m *BitcoinRewardParams) GetFullCoverageBonusFactor() *Decimal {
	if m != nil {
		return m.FullCoverageBonusFactor
	}
	return nil
}

func (m *BitcoinRewardParams) GetPartialCoverageBonusFactor() *Decimal {
	if m != nil {
		return m.PartialCoverageBonusFactor
	}
	return nil
}

// DynamicPricingParams defines the parameters for the dynamic pricing system.
type DynamicPricingParams struct {
	// stability_zone_lower_bound is the lower bound of the stability zone where price doesn't change (0-1)
	StabilityZoneLowerBound *Decimal `protobuf:"bytes,1,opt,name=stability_zone_lower_bound,json=stabilityZoneLowerBound,proto3" json:"stability_zone_lower_bound,omitempty"`
	// stability_zone_upper_bound is the upper bound of the stability zone where price doesn't change (0-1)
	StabilityZoneUpperBound *Decimal `protobuf:"bytes,2,opt,name=stability_zone_upper_bound,json=stabilityZoneUpperBound,proto3" json:"stability_zone_upper_bound,omitempty"`
	// price_elasticity controls price adjustment magnitude - determines maximum change at maximum utilization deviation (0-1)
	PriceElasticity *Decimal `protobuf:"bytes,3,opt,name=price_elasticity,json=priceElasticity,proto3" json:"price_elasticity,omitempty"`
	// utilization_window_duration is the time window in seconds for utilization calculation
	UtilizationWindowDuration uint64 `protobuf:"varint,4,opt,name=utilization_window_duration,json=utilizationWindowDuration,proto3" json:"utilization_window_duration,omitempty"`
	// min_per_token_price is the minimum per-token price floor to prevent zero pricing (in native token units)
	MinPerTokenPrice uint64 `protobuf:"varint,5,opt,name=min_per_token_price,json=minPerTokenPrice,proto3" json:"min_per_token_price,omitempty"`
	// base_per_token_price is the initial per-token price after grace period (in native token units)
	BasePerTokenPrice uint64 `protobuf:"varint,6,opt,name=base_per_token_price,json=basePerTokenPrice,proto3" json:"base_per_token_price,omitempty"`
	// grace_period_end_epoch is the epoch when free inference period ends
	GracePeriodEndEpoch uint64 `protobuf:"varint,7,opt,name=grace_period_end_epoch,json=gracePeriodEndEpoch,proto3" json:"grace_period_end_epoch,omitempty"`
	// grace_period_per_token_price is the per-token price during grace period (default 0 for free)
	GracePeriodPerTokenPrice uint64 `protobuf:"varint,8,opt,name=grace_period_per_token_price,json=gracePeriodPerTokenPrice,proto3" json:"grace_period_per_token_price,omitempty"`
}

func (m *DynamicPricingParams) Reset()         { *m = DynamicPricingParams{} }
func (m *DynamicPricingParams) String() string { return proto.CompactTextString(m) }
func (*DynamicPricingParams) ProtoMessage()    {}
func (*DynamicPricingParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{10}
}
func (m *DynamicPricingParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicPricingParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicPricingParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicPricingParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicPricingParams.Merge(m, src)
}
func (m *DynamicPricingParams) XXX_Size() int {
	return m.Size()
}
func (m *DynamicPricingParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicPricingParams.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicPricingParams proto.InternalMessageInfo

func (m *DynamicPricingParams) GetStabilityZoneLowerBound() *Decimal {
	if m != nil {
		return m.StabilityZoneLowerBound
	}
	return nil
}

func (m *DynamicPricingParams) GetStabilityZoneUpperBound() *Decimal {
	if m != nil {
		return m.StabilityZoneUpperBound
	}
	return nil
}

func (m *DynamicPricingParams) GetPriceElasticity() *Decimal {
	if m != nil {
		return m.PriceElasticity
	}
	return nil
}

func (m *DynamicPricingParams) GetUtilizationWindowDuration() uint64 {
	if m != nil {
		return m.UtilizationWindowDuration
	}
	return 0
}

func (m *DynamicPricingParams) GetMinPerTokenPrice() uint64 {
	if m != nil {
		return m.MinPerTokenPrice
	}
	return 0
}

func (m *DynamicPricingParams) GetBasePerTokenPrice() uint64 {
	if m != nil {
		return m.BasePerTokenPrice
	}
	return 0
}

func (m *DynamicPricingParams) GetGracePeriodEndEpoch() uint64 {
	if m != nil {
		return m.GracePeriodEndEpoch
	}
	return 0
}

func (m *DynamicPricingParams) GetGracePeriodPerTokenPrice() uint64 {
	if m != nil {
		return m.GracePeriodPerTokenPrice
	}
	return 0
}

// BandwidthLimitsParams defines the parameters for request bandwidth limitations.
type BandwidthLimitsParams struct {
	// estimated_limits_per_block_kb is the maximum KB per block that can be consumed
	EstimatedLimitsPerBlockKb uint64 `protobuf:"varint,1,opt,name=estimated_limits_per_block_kb,json=estimatedLimitsPerBlockKb,proto3" json:"estimated_limits_per_block_kb,omitempty"`
	// kb_per_input_token is the estimated KB per input token
	KbPerInputToken *Decimal `protobuf:"bytes,2,opt,name=kb_per_input_token,json=kbPerInputToken,proto3" json:"kb_per_input_token,omitempty"`
	// kb_per_output_token is the estimated KB per output token
	KbPerOutputToken *Decimal `protobuf:"bytes,3,opt,name=kb_per_output_token,json=kbPerOutputToken,proto3" json:"kb_per_output_token,omitempty"`
	// The total max simultaneous invalidations across the chain
	InvalidationsLimit uint64 `protobuf:"varint,4,opt,name=invalidations_limit,json=invalidationsLimit,proto3" json:"invalidations_limit,omitempty"`
	// The seconds to look back to determine inference rate for invalidations
	InvalidationsSamplePeriod uint64 `protobuf:"varint,5,opt,name=invalidations_sample_period,json=invalidationsSamplePeriod,proto3" json:"invalidations_sample_period,omitempty"`
	// The curve for the tanh function for determining how quickly traffic expands the
	// max invalidations allowed
	InvalidationsLimitCurve uint64 `protobuf:"varint,6,opt,name=invalidations_limit_curve,json=invalidationsLimitCurve,proto3" json:"invalidations_limit_curve,omitempty"`
	// The least amount of concurrent invalidations
	MinimumConcurrentInvalidations uint32 `protobuf:"varint,7,opt,name=minimum_concurrent_invalidations,json=minimumConcurrentInvalidations,proto3" json:"minimum_concurrent_invalidations,omitempty"`
	// max_inferences_per_block is the chain-wide limit on inference requests per block
	MaxInferencesPerBlock uint64 `protobuf:"varint,8,opt,name=max_inferences_per_block,json=maxInferencesPerBlock,proto3" json:"max_inferences_per_block,omitempty"`
}

func (m *BandwidthLimitsParams) Reset()         { *m = BandwidthLimitsParams{} }
func (m *BandwidthLimitsParams) String() string { return proto.CompactTextString(m) }
func (*BandwidthLimitsParams) ProtoMessage()    {}
func (*BandwidthLimitsParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{11}
}
func (m *BandwidthLimitsParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BandwidthLimitsParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BandwidthLimitsParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BandwidthLimitsParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BandwidthLimitsParams.Merge(m, src)
}
func (m *BandwidthLimitsParams) XXX_Size() int {
	return m.Size()
}
func (m *BandwidthLimitsParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BandwidthLimitsParams.DiscardUnknown(m)
}

var xxx_messageInfo_BandwidthLimitsParams proto.InternalMessageInfo

func (m *BandwidthLimitsParams) GetEstimatedLimitsPerBlockKb() uint64 {
	if m != nil {
		return m.EstimatedLimitsPerBlockKb
	}
	return 0
}

func (m *BandwidthLimitsParams) GetKbPerInputToken() *Decimal {
	if m != nil {
		return m.KbPerInputToken
	}
	return nil
}

func (m *BandwidthLimitsParams) GetKbPerOutputToken() *Decimal {
	if m != nil {
		return m.KbPerOutputToken
	}
	return nil
}

func (m *BandwidthLimitsParams) GetInvalidationsLimit() uint64 {
	if m != nil {
		return m.InvalidationsLimit
	}
	return 0
}

func (m *BandwidthLimitsParams) GetInvalidationsSamplePeriod() uint64 {
	if m != nil {
		return m.InvalidationsSamplePeriod
	}
	return 0
}

func (m *BandwidthLimitsParams) GetInvalidationsLimitCurve() uint64 {
	if m != nil {
		return m.InvalidationsLimitCurve
	}
	return 0
}

func (m *BandwidthLimitsParams) GetMinimumConcurrentInvalidations() uint32 {
	if m != nil {
		return m.MinimumConcurrentInvalidations
	}
	return 0
}

func (m *BandwidthLimitsParams) GetMaxInferencesPerBlock() uint64 {
	if m != nil {
		return m.MaxInferencesPerBlock
	}
	return 0
}

// ConfirmationPoCParams defines the parameters for confirmation PoC feature.
type ConfirmationPoCParams struct {
	// expected_confirmations_per_epoch is N in the trigger probability formula (e.g., 1)
	ExpectedConfirmationsPerEpoch uint64 `protobuf:"varint,1,opt,name=expected_confirmations_per_epoch,json=expectedConfirmationsPerEpoch,proto3" json:"expected_confirmations_per_epoch,omitempty"`
	// alpha_threshold is the minimum confirmed weight ratio (e.g., "0.70")
	AlphaThreshold *Decimal `protobuf:"bytes,2,opt,name=alpha_threshold,json=alphaThreshold,proto3" json:"alpha_threshold,omitempty"`
	// slash_fraction is the collateral slashed for failure (e.g., "0.10")
	SlashFraction *Decimal `protobuf:"bytes,3,opt,name=slash_fraction,json=slashFraction,proto3" json:"slash_fraction,omitempty"`
	// upgrade_protection_window is blocks before/after upgrade to skip confirmation PoC (default: 500)
	UpgradeProtectionWindow int64 `protobuf:"varint,4,opt,name=upgrade_protection_window,json=upgradeProtectionWindow,proto3" json:"upgrade_protection_window,omitempty"`
}

func (m *ConfirmationPoCParams) Reset()         { *m = ConfirmationPoCParams{} }
func (m *ConfirmationPoCParams) String() string { return proto.CompactTextString(m) }
func (*ConfirmationPoCParams) ProtoMessage()    {}
func (*ConfirmationPoCParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cf34332021bbe94, []int{12}
}
func (m *ConfirmationPoCParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfirmationPoCParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfirmationPoCParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfirmationPoCParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfirmationPoCParams.Merge(m, src)
}
func (m *ConfirmationPoCParams) XXX_Size() int {
	return m.Size()
}
func (m *ConfirmationPoCParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfirmationPoCParams.DiscardUnknown(m)
}

var xxx_messageInfo_ConfirmationPoCParams proto.InternalMessageInfo

func (m *ConfirmationPoCParams) GetExpectedConfirmationsPerEpoch() uint64 {
	if m != nil {
		return m.ExpectedConfirmationsPerEpoch
	}
	return 0
}

func (m *ConfirmationPoCParams) GetAlphaThreshold() *Decimal {
	if m != nil {
		return m.AlphaThreshold
	}
	return nil
}

func (m *ConfirmationPoCParams) GetSlashFraction() *Decimal {
	if m != nil {
		return m.SlashFraction
	}
	return nil
}

func (m *ConfirmationPoCParams) GetUpgradeProtectionWindow() int64 {
	if m != nil {
		return m.UpgradeProtectionWindow
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "inference.inference.Params")
	proto.RegisterType((*GenesisOnlyParams)(nil), "inference.inference.GenesisOnlyParams")
	proto.RegisterType((*TokenomicsParams)(nil), "inference.inference.TokenomicsParams")
	proto.RegisterType((*EpochParams)(nil), "inference.inference.EpochParams")
	proto.RegisterType((*ValidationParams)(nil), "inference.inference.ValidationParams")
	proto.RegisterType((*PoCModelParams)(nil), "inference.inference.PoCModelParams")
	proto.RegisterType((*PocParams)(nil), "inference.inference.PocParams")
	proto.RegisterType((*Decimal)(nil), "inference.inference.Decimal")
	proto.RegisterType((*CollateralParams)(nil), "inference.inference.CollateralParams")
	proto.RegisterType((*BitcoinRewardParams)(nil), "inference.inference.BitcoinRewardParams")
	proto.RegisterType((*DynamicPricingParams)(nil), "inference.inference.DynamicPricingParams")
	proto.RegisterType((*BandwidthLimitsParams)(nil), "inference.inference.BandwidthLimitsParams")
	proto.RegisterType((*ConfirmationPoCParams)(nil), "inference.inference.ConfirmationPoCParams")
}

func init() { proto.RegisterFile("inference/inference/params.proto", fileDescriptor_3cf34332021bbe94) }

var fileDescriptor_3cf34332021bbe94 = []byte{
	// 2950 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x5a, 0x4b, 0x73, 0x1c, 0x37,
	0x92, 0x36, 0x45, 0x36, 0x1f, 0x49, 0x51, 0x6c, 0xa2, 0xd9, 0x64, 0x93, 0xa2, 0x28, 0x4a, 0x5e,
	0xef, 0xca, 0xf6, 0x5a, 0xf2, 0xca, 0xf6, 0x7a, 0xc3, 0x5e, 0x2b, 0x2c, 0x91, 0xd4, 0x63, 0x2d,
	0x5a, 0xbd, 0x45, 0x9a, 0x0e, 0x2b, 0x1c, 0x5b, 0x81, 0xae, 0x42, 0x37, 0x11, 0xac, 0x02, 0x4a,
	0x05, 0x14, 0x1f, 0xfa, 0x09, 0x3b, 0x11, 0x13, 0xf3, 0x13, 0xe6, 0x36, 0xb7, 0x09, 0x9f, 0xe6,
	0x37, 0xcc, 0xd1, 0x87, 0x39, 0xf8, 0x36, 0x13, 0xf6, 0x61, 0xe6, 0x3e, 0xf7, 0x89, 0x09, 0x24,
	0x50, 0x8f, 0x6e, 0xb6, 0xe4, 0xf2, 0x85, 0xd1, 0x95, 0x99, 0xdf, 0x97, 0x28, 0x20, 0x33, 0x91,
	0x40, 0x11, 0xb6, 0xb8, 0xe8, 0xb3, 0x94, 0x89, 0x80, 0xdd, 0x29, 0x7f, 0x25, 0x34, 0xa5, 0xb1,
	0xba, 0x9d, 0xa4, 0x52, 0x4b, 0xd2, 0x2a, 0xe4, 0xb7, 0x8b, 0x5f, 0xeb, 0x4b, 0x34, 0xe6, 0x42,
	0xde, 0xc1, 0xbf, 0xd6, 0x6e, 0x7d, 0x79, 0x20, 0x07, 0x12, 0x7f, 0xde, 0x31, 0xbf, 0x9c, 0x74,
	0x2d, 0x90, 0x2a, 0x96, 0xca, 0xb7, 0x0a, 0xfb, 0x60, 0x55, 0x37, 0xff, 0x30, 0x0d, 0xd3, 0x5d,
	0xf4, 0x44, 0xb6, 0xe1, 0x32, 0x4b, 0x64, 0x70, 0xe4, 0x5b, 0xcf, 0x9d, 0x89, 0xad, 0x89, 0x5b,
	0xf3, 0x77, 0xb7, 0x6e, 0x8f, 0x71, 0x7d, 0x7b, 0xd7, 0x18, 0x5a, 0x9c, 0x37, 0xcf, 0xca, 0x07,
	0xe2, 0xc1, 0xd2, 0x09, 0x8d, 0x78, 0x48, 0x35, 0x97, 0x22, 0x67, 0xba, 0x84, 0x4c, 0x6f, 0x8d,
	0x65, 0x3a, 0x2c, 0xac, 0x1d, 0x5d, 0xf3, 0x64, 0x44, 0x42, 0x3e, 0x03, 0x48, 0x64, 0x90, 0x93,
	0x4d, 0x22, 0xd9, 0xe6, 0x58, 0xb2, 0xae, 0x0c, 0x1c, 0xcb, 0x5c, 0x92, 0xff, 0x34, 0x43, 0xd2,
	0xf2, 0x98, 0x09, 0x19, 0xf3, 0x40, 0xe5, 0x2c, 0x53, 0xaf, 0x19, 0xd2, 0x41, 0x61, 0x9d, 0x0f,
	0x49, 0x8f, 0x48, 0x0c, 0x67, 0x20, 0xa3, 0x88, 0x6a, 0x96, 0xd2, 0x28, 0xe7, 0x6c, 0xbc, 0x86,
	0x73, 0xbb, 0xb0, 0xce, 0x39, 0x83, 0x11, 0x09, 0xf9, 0x16, 0xda, 0x3d, 0xae, 0x03, 0xc9, 0x85,
	0x9f, 0xb2, 0x53, 0x9a, 0x86, 0x39, 0xef, 0x34, 0xf2, 0xde, 0x1a, 0xcb, 0xfb, 0xc0, 0x22, 0x3c,
	0x04, 0x38, 0xea, 0x56, 0xef, 0xa2, 0x90, 0xf8, 0xb0, 0x12, 0x9e, 0x0b, 0x1a, 0xf3, 0xc0, 0x4f,
	0x52, 0x1e, 0x70, 0x31, 0xc8, 0xe9, 0x67, 0x90, 0xfe, 0xed, 0xb1, 0xf4, 0x3b, 0x16, 0xd2, 0xb5,
	0x08, 0xc7, 0xbf, 0x1c, 0x8e, 0x91, 0x92, 0x1e, 0xac, 0xf6, 0xa8, 0x08, 0x4f, 0x79, 0xa8, 0x8f,
	0xfc, 0x88, 0xc7, 0x5c, 0x17, 0x93, 0x3d, 0x8b, 0x1e, 0xde, 0x19, 0xff, 0x02, 0x39, 0xe6, 0x29,
	0x42, 0x9c, 0x8b, 0x76, 0x6f, 0x9c, 0xd8, 0xf8, 0x08, 0xa4, 0xe8, 0xf3, 0x34, 0x76, 0xf1, 0x55,
	0x86, 0xc5, 0xdc, 0x6b, 0x7c, 0x6c, 0x57, 0x30, 0x5d, 0xb9, 0x9d, 0xfb, 0x08, 0x86, 0xc4, 0x2e,
	0x5c, 0x3e, 0x79, 0xeb, 0x6f, 0xbf, 0xbd, 0x3e, 0xf1, 0xff, 0x7f, 0xfd, 0xee, 0x9d, 0x8d, 0x32,
	0x17, 0xcf, 0x2a, 0x79, 0x69, 0xcd, 0x6e, 0x7e, 0x37, 0x03, 0x4b, 0x8f, 0x98, 0x60, 0x8a, 0xab,
	0x67, 0x22, 0x3a, 0x77, 0x03, 0xbc, 0x01, 0x97, 0xb5, 0xd4, 0x34, 0xf2, 0x55, 0x96, 0x24, 0xd1,
	0x39, 0xe6, 0xd0, 0xa4, 0x37, 0x8f, 0xb2, 0x7d, 0x14, 0x91, 0x77, 0x61, 0x49, 0xa6, 0x7c, 0xc0,
	0x05, 0xd5, 0x32, 0xcd, 0xed, 0x2e, 0xa1, 0x5d, 0xb3, 0x54, 0x38, 0xe3, 0x77, 0x4c, 0xec, 0x26,
	0x79, 0x3c, 0xd0, 0x58, 0x66, 0x42, 0x63, 0x06, 0x4c, 0x7a, 0x8b, 0x5a, 0x26, 0x76, 0x85, 0xef,
	0xa3, 0x98, 0x7c, 0x08, 0x2b, 0x4a, 0x53, 0x11, 0x1a, 0xcb, 0x61, 0xc0, 0x14, 0x02, 0x96, 0x73,
	0xed, 0x10, 0xea, 0x53, 0x58, 0x4f, 0x52, 0x66, 0x4a, 0xc3, 0x20, 0xa5, 0x71, 0xcc, 0x42, 0x5f,
	0xd1, 0x88, 0xe5, 0xc8, 0x06, 0x22, 0x57, 0x93, 0x94, 0x75, 0x0b, 0x83, 0x7d, 0x1a, 0x31, 0x07,
	0xbe, 0x0e, 0xf3, 0xe5, 0xf0, 0x6c, 0xa0, 0x36, 0x3c, 0x28, 0x06, 0x86, 0xf3, 0x61, 0xdf, 0xd0,
	0x0f, 0x4d, 0x02, 0x61, 0xac, 0xcd, 0x79, 0xf3, 0x56, 0xb6, 0x63, 0x44, 0x23, 0xaf, 0x98, 0xb0,
	0x94, 0xcb, 0x10, 0x23, 0xa6, 0xfa, 0x8a, 0x5d, 0x14, 0x93, 0x7f, 0x07, 0x52, 0xb5, 0xa5, 0xe7,
	0x32, 0xd3, 0x76, 0xe9, 0x27, 0x4d, 0x92, 0xe6, 0xc6, 0x56, 0x4e, 0xee, 0xc1, 0xc6, 0x45, 0x6b,
	0xe3, 0xc1, 0x8f, 0xb9, 0x60, 0x69, 0x07, 0x10, 0xd7, 0x19, 0xc5, 0x75, 0x59, 0xba, 0x67, 0xf4,
	0xe4, 0x23, 0x58, 0xad, 0xe0, 0x63, 0x7a, 0xe6, 0x87, 0x59, 0x8a, 0xd1, 0xd2, 0x99, 0xb7, 0x33,
	0x5a, 0x40, 0xf7, 0xe8, 0xd9, 0x8e, 0xd3, 0x91, 0x00, 0xae, 0x1b, 0x5b, 0x2e, 0x42, 0x7e, 0xc2,
	0xc3, 0xcc, 0xd4, 0x07, 0x79, 0xca, 0x52, 0xe3, 0x38, 0x60, 0x42, 0xd3, 0x01, 0xeb, 0x5c, 0xc6,
	0x60, 0xdd, 0x18, 0x9f, 0x72, 0x2c, 0xe0, 0x31, 0x8d, 0xbc, 0x8d, 0x98, 0x9e, 0x3d, 0x29, 0x38,
	0xba, 0x86, 0xa2, 0x5b, 0x30, 0x90, 0xff, 0x82, 0xce, 0xc0, 0x46, 0x9f, 0x3f, 0xc8, 0x68, 0x1a,
	0x72, 0x2a, 0x7c, 0x26, 0x68, 0x2f, 0x62, 0x61, 0x67, 0x61, 0x6b, 0xe2, 0xd6, 0xac, 0xb7, 0xe2,
	0xf4, 0x8f, 0x9c, 0x7a, 0xd7, 0x6a, 0xc9, 0xb7, 0xf0, 0xee, 0x05, 0xa4, 0x60, 0xfa, 0x54, 0xa6,
	0xc7, 0x7e, 0x4c, 0x75, 0x96, 0x72, 0x7d, 0xee, 0xeb, 0xa3, 0x94, 0xa9, 0x23, 0x19, 0x85, 0x9d,
	0x2b, 0xf8, 0xa6, 0xff, 0x36, 0x42, 0xf6, 0xa5, 0x05, 0xec, 0x39, 0xfb, 0x83, 0xdc, 0x9c, 0x7c,
	0x0b, 0x57, 0x2f, 0xb0, 0xc7, 0x59, 0xa4, 0x79, 0x12, 0x71, 0x96, 0x76, 0x16, 0x6b, 0xbc, 0xf8,
	0xda, 0x88, 0xaf, 0xbd, 0x02, 0x4e, 0xfe, 0x1b, 0xd6, 0x2f, 0xb0, 0xd3, 0x30, 0x4c, 0x99, 0x52,
	0x4c, 0x75, 0x9a, 0x5b, 0x93, 0xb7, 0xe6, 0xbc, 0xce, 0x08, 0xfc, 0x7e, 0xae, 0xbf, 0xf9, 0xe7,
	0x29, 0x68, 0x8e, 0xd6, 0x76, 0xf2, 0x1c, 0xd6, 0x55, 0xd6, 0x53, 0x3c, 0x3c, 0xf7, 0x53, 0x16,
	0x66, 0x01, 0xd6, 0x15, 0x2e, 0x34, 0x4b, 0x4f, 0x68, 0xe4, 0xf6, 0xc0, 0xd7, 0x8f, 0xb7, 0xe3,
	0xf0, 0x5e, 0x0e, 0x7f, 0xe2, 0xd0, 0xe4, 0x10, 0x3a, 0x17, 0xb9, 0x5d, 0x66, 0x5d, 0xaa, 0xc1,
	0xbc, 0x32, 0xca, 0xec, 0xd2, 0xee, 0x39, 0xac, 0x07, 0x59, 0x9a, 0x32, 0xa1, 0xfd, 0x9c, 0xbf,
	0x12, 0x5c, 0x93, 0x75, 0xc6, 0xec, 0xf0, 0xfb, 0x16, 0x5e, 0x09, 0xac, 0x6f, 0x60, 0xbd, 0x5a,
	0x71, 0xa2, 0x48, 0x9e, 0xb2, 0xd0, 0xef, 0x53, 0x1e, 0x65, 0x29, 0x73, 0xdb, 0xe6, 0xeb, 0xb9,
	0x57, 0xcb, 0xc2, 0x64, 0xd1, 0x0f, 0x2d, 0x98, 0x7c, 0x06, 0x57, 0x0d, 0x35, 0x26, 0x1f, 0x96,
	0xee, 0x17, 0x19, 0x8d, 0x78, 0x9f, 0x07, 0x36, 0xa7, 0x1a, 0x45, 0x3a, 0x62, 0xfa, 0x75, 0x65,
	0xf0, 0xbf, 0x55, 0x3d, 0xb9, 0x0d, 0x2d, 0x0c, 0xd2, 0x13, 0xa6, 0x34, 0x6e, 0x5f, 0xb6, 0x54,
	0x98, 0xa2, 0x33, 0xe5, 0x2d, 0x19, 0xd5, 0xa1, 0xd5, 0xb8, 0x62, 0x71, 0x17, 0xda, 0xee, 0x2d,
	0x46, 0x10, 0x33, 0x88, 0x68, 0x59, 0xe5, 0x30, 0xe6, 0x63, 0xe8, 0x94, 0x43, 0x1c, 0x81, 0xcd,
	0x22, 0xac, 0x9d, 0x8f, 0x6f, 0x08, 0xf8, 0xc9, 0x94, 0xd9, 0x35, 0x6e, 0xfe, 0xa3, 0x01, 0xf3,
	0x95, 0xd6, 0xc8, 0x94, 0x3f, 0xdb, 0x52, 0x45, 0x4c, 0x0c, 0xf4, 0x51, 0xbe, 0x1d, 0xa0, 0xec,
	0x29, 0x8a, 0xc8, 0xdb, 0xd0, 0xb4, 0x26, 0x95, 0x2c, 0xb1, 0xbb, 0xc1, 0x22, 0xca, 0x2b, 0xd1,
	0x7f, 0x1d, 0x2c, 0xd2, 0x57, 0x47, 0xbc, 0x9f, 0x6f, 0x03, 0x80, 0xa2, 0x7d, 0x23, 0x21, 0x9f,
	0xc3, 0xb5, 0x90, 0xf5, 0x69, 0x16, 0x69, 0x3f, 0x13, 0x5c, 0xfb, 0xb2, 0xef, 0x07, 0x32, 0x4e,
	0x32, 0xcd, 0x70, 0xcf, 0x67, 0x6e, 0x23, 0x58, 0x73, 0x46, 0x5f, 0x09, 0xae, 0x9f, 0xf5, 0xb7,
	0xad, 0x85, 0xd9, 0xcc, 0x99, 0x29, 0xb0, 0x66, 0x61, 0x94, 0x09, 0x85, 0xb2, 0xda, 0xd9, 0x95,
	0x69, 0x26, 0x32, 0xd8, 0x37, 0x8a, 0xa2, 0xd2, 0xdd, 0x85, 0xb6, 0xb1, 0x66, 0x67, 0xc1, 0x11,
	0x15, 0x55, 0xc0, 0x34, 0x02, 0x5a, 0x89, 0x0c, 0x76, 0x9d, 0xae, 0xc0, 0xbc, 0x0f, 0xcb, 0x06,
	0x53, 0x69, 0x12, 0x43, 0x16, 0xd1, 0x73, 0x5c, 0x94, 0x49, 0xcf, 0x78, 0x2f, 0x3b, 0xc2, 0x1d,
	0xa3, 0x21, 0xff, 0x09, 0xab, 0xa3, 0x88, 0xdc, 0x8f, 0xdd, 0x26, 0xda, 0xc3, 0xa0, 0xdc, 0xd3,
	0xc7, 0xd0, 0x51, 0x4c, 0xfb, 0x82, 0x9d, 0xe6, 0x58, 0x99, 0x2a, 0xe7, 0xcd, 0x6e, 0x19, 0x6d,
	0xc5, 0xf4, 0x97, 0xec, 0xf4, 0xb0, 0xd0, 0x5a, 0x87, 0xf7, 0xe0, 0x6a, 0x11, 0xd5, 0x55, 0xb7,
	0x41, 0xa6, 0x65, 0xbf, 0xef, 0xb6, 0x8d, 0xb5, 0xc2, 0xa4, 0x74, 0xbd, 0x8d, 0x06, 0xe4, 0x09,
	0xdc, 0x28, 0xf1, 0x49, 0x9a, 0x09, 0x13, 0x44, 0x76, 0xe5, 0xca, 0xba, 0x3a, 0x8f, 0xd1, 0xb4,
	0x59, 0x18, 0x76, 0xad, 0x1d, 0x46, 0x4f, 0x59, 0x4e, 0xef, 0x42, 0xfb, 0x22, 0x55, 0x4c, 0xcf,
	0x70, 0x07, 0x99, 0xf4, 0x5a, 0xa3, 0xf0, 0x3d, 0x7a, 0x46, 0xfe, 0x15, 0x16, 0xb1, 0x2f, 0xaa,
	0x58, 0x2f, 0xa0, 0xf5, 0x82, 0xe9, 0x89, 0x4b, 0xbb, 0xa7, 0xd0, 0xc2, 0xb5, 0x8e, 0xa4, 0xc6,
	0x3c, 0x77, 0x69, 0x78, 0xa5, 0x46, 0x8a, 0x2f, 0x99, 0x50, 0x88, 0xa4, 0xbe, 0x5f, 0xc0, 0x5c,
	0x02, 0xfc, 0xfa, 0x0a, 0x34, 0x47, 0x3b, 0x7a, 0xe3, 0xa8, 0x4f, 0x23, 0xc5, 0xfc, 0x44, 0x2a,
	0xae, 0xf9, 0x09, 0xf3, 0x53, 0xaa, 0x59, 0xad, 0xda, 0xba, 0x84, 0xc0, 0xae, 0xc3, 0x79, 0x54,
	0x33, 0xb3, 0xac, 0xb1, 0x69, 0x91, 0x69, 0x9c, 0xf8, 0x59, 0xe2, 0xc7, 0x8c, 0xaa, 0x2c, 0x65,
	0x31, 0x13, 0xda, 0x1e, 0x34, 0x1a, 0x5e, 0x3b, 0xe6, 0xc2, 0xa3, 0x71, 0xf2, 0x55, 0xb2, 0x57,
	0x51, 0x92, 0x4f, 0x01, 0x12, 0xaa, 0x94, 0x59, 0xd1, 0xac, 0x5e, 0x95, 0x9c, 0x33, 0xf6, 0x87,
	0xc6, 0x9c, 0x78, 0xb0, 0x62, 0xbc, 0x56, 0xa2, 0x81, 0x9e, 0xb0, 0xd4, 0x94, 0xdb, 0x3a, 0x25,
	0x71, 0x39, 0xe6, 0xa2, 0x9c, 0x96, 0xfb, 0x16, 0x89, 0x9c, 0xf4, 0x6c, 0x1c, 0x67, 0xa3, 0x16,
	0x27, 0x3d, 0xbb, 0xc8, 0xf9, 0x2e, 0x2c, 0xb1, 0xb3, 0x84, 0xdb, 0x14, 0xf0, 0x7b, 0x91, 0x0c,
	0x8e, 0x95, 0x4b, 0xc7, 0x66, 0xa9, 0x78, 0x80, 0x72, 0x72, 0x13, 0x16, 0x30, 0x2c, 0x95, 0xaf,
	0x25, 0xc6, 0xc9, 0x4c, 0xa5, 0x3e, 0xa9, 0x03, 0x69, 0xa2, 0x64, 0x1b, 0x36, 0xfb, 0x59, 0x14,
	0x55, 0x47, 0xa9, 0x53, 0xda, 0xef, 0xf3, 0x20, 0xcf, 0x07, 0x9b, 0x84, 0x57, 0x8d, 0x55, 0x39,
	0x9e, 0x03, 0x6b, 0xe3, 0x32, 0xe2, 0xe2, 0xec, 0x1d, 0xd1, 0xa8, 0x7f, 0xea, 0x12, 0xf1, 0x97,
	0xcd, 0xde, 0x63, 0x8b, 0x24, 0xf7, 0xe1, 0xda, 0x08, 0xe7, 0xc8, 0xb8, 0x6c, 0x9e, 0xae, 0x0f,
	0x81, 0xc7, 0x0c, 0x4b, 0xa9, 0xca, 0xe6, 0x99, 0x63, 0xe7, 0xeb, 0x0d, 0x4b, 0xa9, 0x72, 0xe7,
	0x74, 0x9c, 0x5d, 0x68, 0x23, 0x67, 0xca, 0x5e, 0x64, 0x4c, 0x61, 0xbf, 0x29, 0x68, 0xa4, 0xcf,
	0x6b, 0xf5, 0x7c, 0x2d, 0x03, 0xf5, 0x1c, 0xb2, 0x6b, 0x81, 0xe4, 0x3f, 0x60, 0x59, 0xf3, 0x98,
	0x29, 0x6d, 0x22, 0xbe, 0x5c, 0x43, 0x97, 0xd4, 0xad, 0x42, 0xb7, 0x5b, 0xa8, 0x4c, 0x14, 0x94,
	0x10, 0x1a, 0x9e, 0x50, 0x11, 0x30, 0xd7, 0xc9, 0x35, 0x0b, 0xc5, 0x7d, 0x2b, 0x37, 0xbb, 0x86,
	0xd9, 0xca, 0x62, 0xaa, 0x59, 0x58, 0x1c, 0xdc, 0x58, 0x6a, 0x83, 0xc7, 0x3f, 0xee, 0x61, 0xd3,
	0x36, 0xe5, 0xad, 0x15, 0x46, 0xee, 0x48, 0xc6, 0x52, 0x0c, 0xa3, 0x2f, 0x7a, 0xa6, 0xe9, 0xe3,
	0x02, 0x17, 0xc2, 0x4f, 0x59, 0x92, 0x69, 0x77, 0x38, 0x4b, 0x99, 0x62, 0xe9, 0x09, 0xeb, 0x34,
	0xeb, 0x34, 0x7d, 0x8e, 0xc0, 0x2b, 0xf0, 0x5d, 0x07, 0x27, 0x03, 0xb8, 0xd1, 0xa3, 0x78, 0x18,
	0xd6, 0x3c, 0xe0, 0x09, 0x15, 0xda, 0x77, 0xc6, 0xd6, 0x0f, 0x16, 0x93, 0xa5, 0x1a, 0x3e, 0x36,
	0x7b, 0xd4, 0x9c, 0x86, 0x73, 0x96, 0x27, 0x15, 0x12, 0xac, 0x2c, 0x87, 0xd0, 0x19, 0x22, 0xae,
	0x96, 0x6b, 0x52, 0xa7, 0x5d, 0xab, 0xa2, 0x1f, 0x97, 0x45, 0xfc, 0x10, 0x3a, 0xa1, 0x3c, 0x15,
	0x66, 0xe2, 0xfd, 0x81, 0x94, 0x61, 0xb5, 0x59, 0x6b, 0xd5, 0xe1, 0xcd, 0xd1, 0x8f, 0xa4, 0x0c,
	0x2b, 0xad, 0xda, 0x01, 0xac, 0x16, 0xbc, 0x38, 0x43, 0x25, 0xed, 0x72, 0x0d, 0xda, 0x76, 0x0e,
	0x7e, 0x40, 0xab, 0xac, 0x5f, 0xc2, 0x72, 0xc1, 0x5a, 0x9d, 0x81, 0x76, 0x0d, 0x4a, 0x92, 0x23,
	0x2b, 0x6f, 0xff, 0x7f, 0xb0, 0x51, 0xf0, 0x8d, 0x8b, 0x8e, 0x95, 0x1a, 0xbc, 0xeb, 0x39, 0xc3,
	0x98, 0xf0, 0x38, 0x80, 0xd5, 0x17, 0x19, 0x0f, 0x8e, 0xf3, 0x1e, 0xb5, 0x32, 0xe4, 0xd5, 0x3a,
	0xb3, 0x80, 0x60, 0xd7, 0xa2, 0x96, 0xa3, 0xfe, 0x1c, 0x16, 0x7a, 0x5c, 0xc8, 0xd8, 0xd7, 0x4c,
	0x69, 0x3f, 0x79, 0xbf, 0xd3, 0xa9, 0xc1, 0x35, 0x8f, 0x90, 0x03, 0xa6, 0x74, 0xf7, 0x7d, 0xb7,
	0x21, 0xfe, 0x30, 0x09, 0x57, 0xba, 0x72, 0x7b, 0x4f, 0x86, 0x2c, 0xbf, 0xe7, 0x69, 0xc2, 0x64,
	0xc8, 0x63, 0xdc, 0xfe, 0x1a, 0x9e, 0xf9, 0x49, 0xd6, 0x60, 0x56, 0xf8, 0x11, 0x3d, 0x67, 0x69,
	0xbe, 0x85, 0xcd, 0x88, 0xa7, 0xf8, 0x48, 0x56, 0x61, 0x46, 0xf8, 0x47, 0x8c, 0x86, 0xf6, 0xe2,
	0xab, 0xe1, 0x4d, 0x8b, 0xc7, 0xe6, 0x89, 0x6c, 0x00, 0x08, 0xff, 0xf8, 0xc4, 0xe9, 0xa6, 0x50,
	0x37, 0x2b, 0xbe, 0x38, 0xb1, 0xda, 0x6b, 0x00, 0x27, 0x32, 0xa0, 0x3d, 0x5f, 0xf1, 0x97, 0x76,
	0x3b, 0x69, 0x78, 0x73, 0x28, 0xd9, 0xe7, 0x2f, 0x19, 0xf9, 0x1f, 0x20, 0xfd, 0xbe, 0xf0, 0x43,
	0x1e, 0x57, 0xdb, 0xce, 0xe9, 0x1a, 0xaf, 0xd8, 0xec, 0xf7, 0xc5, 0x0e, 0x8f, 0x87, 0xbb, 0x52,
	0xc7, 0xc1, 0x7c, 0xd9, 0xc7, 0x2d, 0xa4, 0xe1, 0x41, 0x2e, 0x7a, 0xd6, 0x27, 0x1f, 0xc3, 0xac,
	0x90, 0x69, 0xec, 0xb3, 0x24, 0xbf, 0x09, 0x7a, 0xbd, 0x8b, 0x19, 0x63, 0xbd, 0x9b, 0xe0, 0x4b,
	0xa4, 0x32, 0x31, 0x0b, 0xca, 0x34, 0xc5, 0x9d, 0xa2, 0xe1, 0xcd, 0x19, 0xc9, 0x81, 0x11, 0x98,
	0x3e, 0x27, 0x53, 0xcc, 0x57, 0x01, 0x8d, 0x58, 0xe8, 0x1b, 0x39, 0x96, 0xfc, 0x59, 0x6f, 0x21,
	0x53, 0x6c, 0x1f, 0xa5, 0x9e, 0x4c, 0x98, 0x99, 0x42, 0xc5, 0x5e, 0x98, 0x16, 0x1c, 0xcb, 0x7a,
	0xc3, 0x9b, 0x56, 0xec, 0xc5, 0x53, 0x66, 0x1a, 0xc4, 0xd9, 0xd4, 0xd7, 0x34, 0x1d, 0x30, 0x5d,
	0xab, 0x3a, 0xcf, 0xa4, 0x07, 0x68, 0xec, 0x96, 0xf6, 0x4f, 0x97, 0x60, 0xae, 0xb8, 0x36, 0x22,
	0xef, 0x01, 0xc9, 0x7b, 0xef, 0x90, 0x9b, 0x3d, 0x26, 0x33, 0x45, 0xdf, 0x2e, 0xf2, 0x92, 0xd3,
	0xec, 0x14, 0x0a, 0xf2, 0x21, 0xac, 0x54, 0x2a, 0x8d, 0xa2, 0xb1, 0x99, 0x3e, 0x5c, 0x2c, 0x1b,
	0x00, 0xcb, 0xa5, 0x76, 0x1f, 0x95, 0xb8, 0x6e, 0x0f, 0x61, 0xcb, 0xb4, 0x6c, 0x21, 0xd5, 0xf4,
	0x95, 0x8d, 0xe5, 0x24, 0x56, 0xeb, 0x8d, 0x44, 0x06, 0x3b, 0x54, 0xd3, 0xf1, 0x6d, 0xe5, 0x53,
	0x68, 0x9d, 0x32, 0x3e, 0x38, 0xd2, 0x76, 0xf6, 0xfc, 0x3e, 0x0d, 0xb4, 0x4c, 0x6b, 0xb5, 0x32,
	0x4b, 0x16, 0x88, 0xf3, 0xfb, 0x10, 0x61, 0xe4, 0x21, 0x5c, 0x8e, 0x4d, 0x7c, 0x0f, 0xdf, 0x83,
	0xbe, 0xf9, 0x8a, 0x1b, 0xda, 0x6a, 0x2e, 0x78, 0xf3, 0x71, 0xf9, 0xe0, 0xa6, 0xf5, 0x3e, 0xcc,
	0x38, 0x5f, 0x64, 0x19, 0x1a, 0xb6, 0x59, 0xb3, 0xe7, 0x26, 0xfb, 0x40, 0xd6, 0x61, 0x96, 0x9d,
	0x25, 0x52, 0x30, 0x77, 0x8a, 0x6e, 0x78, 0xc5, 0xb3, 0xa3, 0xf8, 0xd5, 0x14, 0x34, 0x47, 0x2f,
	0x5c, 0xcd, 0x66, 0xaf, 0x22, 0xaa, 0x8e, 0xfc, 0x7e, 0x4a, 0xf3, 0x53, 0x3e, 0x4e, 0x72, 0xad,
	0x46, 0x74, 0x19, 0xb1, 0x0f, 0x1d, 0xd4, 0x6d, 0x1d, 0xa6, 0xf6, 0x8c, 0x70, 0xe6, 0x85, 0xaa,
	0xd6, 0xf9, 0xbe, 0x3d, 0x44, 0xba, 0xe3, 0xa0, 0x24, 0x86, 0x7f, 0x29, 0x2a, 0xa6, 0x69, 0x08,
	0x58, 0xb5, 0xb4, 0x8f, 0xac, 0xf4, 0xcf, 0xb9, 0xb8, 0x91, 0x33, 0xed, 0x21, 0x51, 0x59, 0xe7,
	0xcb, 0x60, 0xf8, 0x00, 0x56, 0x06, 0x29, 0x35, 0xe7, 0x0b, 0x3c, 0xca, 0xfa, 0x4c, 0x84, 0x36,
	0xa8, 0x30, 0x1e, 0xa6, 0xbc, 0x16, 0x6a, 0xed, 0x39, 0x77, 0x57, 0x84, 0x18, 0x4a, 0xe4, 0x31,
	0x2c, 0xf5, 0xa8, 0x62, 0xbe, 0x0b, 0x23, 0xec, 0x3b, 0x6a, 0xb5, 0xad, 0x8b, 0x06, 0xf6, 0x35,
	0xa2, 0x3c, 0x03, 0x22, 0xdf, 0xc0, 0x7a, 0xf5, 0x2a, 0x9d, 0xa5, 0x39, 0xa7, 0x39, 0xc2, 0xd6,
	0xaa, 0x49, 0xab, 0x95, 0xab, 0x74, 0x96, 0x5a, 0x6e, 0x73, 0xb6, 0x75, 0xd1, 0xf0, 0xf7, 0x49,
	0x68, 0x8d, 0xb9, 0x26, 0x27, 0xb7, 0xa1, 0x65, 0xea, 0xc7, 0xf0, 0x9d, 0xbb, 0xfd, 0xec, 0x31,
	0xeb, 0x2d, 0x65, 0x8a, 0x0d, 0x81, 0x94, 0x39, 0xb9, 0x72, 0xc1, 0x35, 0xa7, 0x91, 0xcb, 0x39,
	0x8b, 0xc0, 0x95, 0x9e, 0xf2, 0x88, 0xd3, 0xe1, 0xf4, 0x58, 0x88, 0x39, 0x71, 0x84, 0x2c, 0xa0,
	0xe7, 0xb6, 0x45, 0xa9, 0x75, 0xe2, 0x40, 0x7b, 0xec, 0x46, 0xde, 0x84, 0x85, 0xfc, 0xae, 0xab,
	0xba, 0x1a, 0x97, 0x9d, 0xd0, 0x2e, 0xc3, 0x21, 0x74, 0x32, 0xcd, 0x23, 0xfe, 0xd2, 0xf5, 0xfb,
	0x52, 0x64, 0x2a, 0xcf, 0xe6, 0x3a, 0xab, 0xb1, 0x52, 0x41, 0x3f, 0x30, 0x60, 0x97, 0xd2, 0xdf,
	0xc0, 0x3a, 0x76, 0xfd, 0x81, 0xb4, 0xe7, 0x8a, 0x61, 0xe6, 0x5a, 0x8b, 0x62, 0xf0, 0xdb, 0x0e,
	0x5e, 0xa5, 0xf6, 0xe1, 0x1a, 0xb6, 0x72, 0xf4, 0x55, 0xec, 0x33, 0x75, 0x1a, 0x02, 0x47, 0x31,
	0xc6, 0x81, 0x5b, 0xf5, 0xef, 0xa6, 0x60, 0x79, 0xdc, 0xd7, 0x0b, 0xf3, 0x6a, 0x4a, 0xd3, 0x1e,
	0x8f, 0xb8, 0x3e, 0xf7, 0x5f, 0x4a, 0xc1, 0xfc, 0x08, 0xaf, 0x67, 0x7b, 0x32, 0x13, 0xf5, 0x6a,
	0xc1, 0x6a, 0x81, 0x7f, 0x2e, 0x05, 0x7b, 0x6a, 0xd0, 0x0f, 0x0c, 0x78, 0x0c, 0x75, 0x96, 0x24,
	0x05, 0xf5, 0xa5, 0x5f, 0x4c, 0xfd, 0x95, 0x41, 0x5b, 0xea, 0x47, 0xd0, 0xc4, 0x2b, 0x1c, 0x9f,
	0x45, 0x54, 0x99, 0x0e, 0x56, 0x9f, 0xd7, 0x0a, 0xa8, 0x45, 0x44, 0xed, 0x16, 0x20, 0x72, 0x0f,
	0xae, 0x56, 0x23, 0xe6, 0x94, 0x8b, 0x50, 0x9e, 0x96, 0x37, 0x2a, 0x36, 0xc8, 0xd6, 0x2a, 0x26,
	0x5f, 0xa3, 0x45, 0x71, 0xab, 0xf2, 0x1e, 0xb4, 0xcc, 0xb1, 0xcb, 0xbc, 0x16, 0x7e, 0x15, 0x73,
	0x37, 0x4b, 0x0d, 0xc4, 0x35, 0x63, 0x2e, 0xba, 0x2c, 0xc5, 0x4b, 0x56, 0x7b, 0xa1, 0x74, 0x07,
	0x96, 0xb1, 0x4e, 0x8c, 0xda, 0xbb, 0x5b, 0x3b, 0xa3, 0x1b, 0x06, 0xbc, 0xba, 0x1a, 0xcd, 0xbc,
	0xba, 0x1a, 0xdd, 0x83, 0x8d, 0x21, 0xd0, 0xa8, 0x37, 0x7b, 0x75, 0xd7, 0xa9, 0x40, 0x87, 0x9c,
	0xba, 0x90, 0xf9, 0xdd, 0x14, 0xb4, 0xc7, 0x7e, 0x8e, 0xfa, 0xf9, 0x23, 0xd2, 0xc4, 0xcf, 0x1d,
	0x91, 0x9e, 0x00, 0x39, 0xee, 0x21, 0x86, 0x8b, 0x24, 0xd3, 0x76, 0x74, 0xb5, 0x42, 0x62, 0xf1,
	0xb8, 0xd7, 0x65, 0xe9, 0x13, 0x83, 0xc2, 0x11, 0x93, 0x2f, 0xa0, 0xe5, 0xa8, 0x64, 0xa6, 0x4b,
	0xae, 0x3a, 0xd1, 0xd0, 0x44, 0xae, 0x67, 0x08, 0xb3, 0x64, 0x77, 0xa0, 0x55, 0x3d, 0xb5, 0x28,
	0xfb, 0x76, 0x2e, 0x0c, 0xc8, 0x90, 0x0a, 0xdf, 0xc9, 0x5e, 0x8e, 0x55, 0x01, 0xae, 0x77, 0x71,
	0x97, 0xa4, 0x36, 0x0e, 0xd6, 0x86, 0x4c, 0x6c, 0x03, 0xe3, 0x6e, 0x58, 0x3f, 0x81, 0xb5, 0x31,
	0x0e, 0xfd, 0x20, 0x33, 0x67, 0x01, 0x1b, 0x15, 0xab, 0x17, 0xdd, 0x6e, 0x1b, 0x35, 0x79, 0x0c,
	0x5b, 0x31, 0x17, 0x3c, 0xce, 0x62, 0x3f, 0x90, 0x22, 0xbf, 0x02, 0x1f, 0xb2, 0xc6, 0x28, 0x59,
	0xf0, 0x36, 0x9d, 0xdd, 0x76, 0x61, 0x56, 0x3d, 0xed, 0x29, 0xbc, 0x44, 0xc2, 0x6f, 0x34, 0x6e,
	0x86, 0x2a, 0xcb, 0x99, 0xdf, 0xf3, 0xe2, 0xe7, 0x97, 0x5c, 0x9d, 0xaf, 0xa4, 0x8b, 0x94, 0xdf,
	0x5f, 0x82, 0xf6, 0xd8, 0x8f, 0x8a, 0xe4, 0x11, 0x6c, 0xb1, 0xb3, 0x84, 0x05, 0x26, 0x50, 0xaa,
	0xdf, 0x17, 0xad, 0x03, 0x1b, 0xc8, 0x36, 0x58, 0xae, 0xe5, 0x76, 0x55, 0x22, 0xe3, 0xc8, 0x86,
	0xf4, 0x2e, 0x2c, 0xd2, 0x28, 0x39, 0xa2, 0x95, 0xfd, 0xbe, 0x4e, 0xb4, 0x5c, 0x41, 0x50, 0xb9,
	0xb9, 0x6f, 0xc3, 0x95, 0xe1, 0x0e, 0xa5, 0x56, 0x9c, 0x2c, 0x0c, 0x35, 0x26, 0x66, 0xcd, 0xb2,
	0x64, 0x90, 0xd2, 0x10, 0xbf, 0x13, 0x6a, 0x16, 0x54, 0x4a, 0x87, 0xbb, 0x53, 0x5e, 0x75, 0x06,
	0xdd, 0x42, 0x6f, 0xeb, 0x86, 0x9d, 0xb0, 0x07, 0xcf, 0xfe, 0xf8, 0xe3, 0xe6, 0xc4, 0xf7, 0x3f,
	0x6e, 0x4e, 0xfc, 0xe5, 0xc7, 0xcd, 0x89, 0xdf, 0xfc, 0xb4, 0xf9, 0xc6, 0xf7, 0x3f, 0x6d, 0xbe,
	0xf1, 0xc3, 0x4f, 0x9b, 0x6f, 0x3c, 0xff, 0x68, 0xc0, 0xf5, 0x51, 0xd6, 0xbb, 0x1d, 0xc8, 0xf8,
	0x4e, 0x92, 0xca, 0x30, 0x0b, 0xb4, 0x0a, 0xf8, 0xc8, 0xff, 0x42, 0x54, 0xbf, 0xbf, 0xea, 0xf3,
	0x84, 0xa9, 0xde, 0x34, 0xfe, 0xfb, 0xc2, 0x07, 0xff, 0x0c, 0x00, 0x00, 0xff, 0xff, 0xde, 0xcb,
	0x47, 0xcb, 0x3b, 0x21, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EpochParams.Equal(that1.EpochParams) {
		return false
	}
	if !this.ValidationParams.Equal(that1.ValidationParams) {
		return false
	}
	if !this.PocParams.Equal(that1.PocParams) {
		return false
	}
	if !this.TokenomicsParams.Equal(that1.TokenomicsParams) {
		return false
	}
	if !this.CollateralParams.Equal(that1.CollateralParams) {
		return false
	}
	if !this.BitcoinRewardParams.Equal(that1.BitcoinRewardParams) {
		return false
	}
	if !this.DynamicPricingParams.Equal(that1.DynamicPricingParams) {
		return false
	}
	if !this.BandwidthLimitsParams.Equal(that1.BandwidthLimitsParams) {
		return false
	}
	if !this.ConfirmationPocParams.Equal(that1.ConfirmationPocParams) {
		return false
	}
	return true
}
func (this *TokenomicsParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TokenomicsParams)
	if !ok {
		that2, ok := that.(TokenomicsParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubsidyReductionInterval.Equal(that1.SubsidyReductionInterval) {
		return false
	}
	if !this.SubsidyReductionAmount.Equal(that1.SubsidyReductionAmount) {
		return false
	}
	if !this.CurrentSubsidyPercentage.Equal(that1.CurrentSubsidyPercentage) {
		return false
	}
	if !this.TopRewardAllowedFailure.Equal(that1.TopRewardAllowedFailure) {
		return false
	}
	if this.TopMinerPocQualification != that1.TopMinerPocQualification {
		return false
	}
	if this.WorkVestingPeriod != that1.WorkVestingPeriod {
		return false
	}
	if this.RewardVestingPeriod != that1.RewardVestingPeriod {
		return false
	}
	if this.TopMinerVestingPeriod != that1.TopMinerVestingPeriod {
		return false
	}
	return true
}
func (this *EpochParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EpochParams)
	if !ok {
		that2, ok := that.(EpochParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EpochLength != that1.EpochLength {
		return false
	}
	if this.EpochMultiplier != that1.EpochMultiplier {
		return false
	}
	if this.EpochShift != that1.EpochShift {
		return false
	}
	if this.DefaultUnitOfComputePrice != that1.DefaultUnitOfComputePrice {
		return false
	}
	if this.PocStageDuration != that1.PocStageDuration {
		return false
	}
	if this.PocExchangeDuration != that1.PocExchangeDuration {
		return false
	}
	if this.PocValidationDelay != that1.PocValidationDelay {
		return false
	}
	if this.PocValidationDuration != that1.PocValidationDuration {
		return false
	}
	if this.SetNewValidatorsDelay != that1.SetNewValidatorsDelay {
		return false
	}
	if this.InferenceValidationCutoff != that1.InferenceValidationCutoff {
		return false
	}
	if this.InferencePruningEpochThreshold != that1.InferencePruningEpochThreshold {
		return false
	}
	if this.InferencePruningMax != that1.InferencePruningMax {
		return false
	}
	if this.PocPruningMax != that1.PocPruningMax {
		return false
	}
	if !this.PocSlotAllocation.Equal(that1.PocSlotAllocation) {
		return false
	}
	return true
}
func (this *ValidationParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidationParams)
	if !ok {
		that2, ok := that.(ValidationParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FalsePositiveRate.Equal(that1.FalsePositiveRate) {
		return false
	}
	if this.MinRampUpMeasurements != that1.MinRampUpMeasurements {
		return false
	}
	if !this.PassValue.Equal(that1.PassValue) {
		return false
	}
	if !this.MinValidationAverage.Equal(that1.MinValidationAverage) {
		return false
	}
	if !this.MaxValidationAverage.Equal(that1.MaxValidationAverage) {
		return false
	}
	if this.ExpirationBlocks != that1.ExpirationBlocks {
		return false
	}
	if this.EpochsToMax != that1.EpochsToMax {
		return false
	}
	if this.FullValidationTrafficCutoff != that1.FullValidationTrafficCutoff {
		return false
	}
	if !this.MinValidationHalfway.Equal(that1.MinValidationHalfway) {
		return false
	}
	if this.MinValidationTrafficCutoff != that1.MinValidationTrafficCutoff {
		return false
	}
	if !this.MissPercentageCutoff.Equal(that1.MissPercentageCutoff) {
		return false
	}
	if !this.MissRequestsPenalty.Equal(that1.MissRequestsPenalty) {
		return false
	}
	if this.TimestampExpiration != that1.TimestampExpiration {
		return false
	}
	if this.TimestampAdvance != that1.TimestampAdvance {
		return false
	}
	if this.EstimatedLimitsPerBlockKb != that1.EstimatedLimitsPerBlockKb {
		return false
	}
	if !this.InvalidReputationPreserve.Equal(that1.InvalidReputationPreserve) {
		return false
	}
	if !this.BadParticipantInvalidationRate.Equal(that1.BadParticipantInvalidationRate) {
		return false
	}
	if !this.InvalidationHThreshold.Equal(that1.InvalidationHThreshold) {
		return false
	}
	if !this.DowntimeGoodPercentage.Equal(that1.DowntimeGoodPercentage) {
		return false
	}
	if !this.DowntimeBadPercentage.Equal(that1.DowntimeBadPercentage) {
		return false
	}
	if !this.DowntimeHThreshold.Equal(that1.DowntimeHThreshold) {
		return false
	}
	if !this.DowntimeReputationPreserve.Equal(that1.DowntimeReputationPreserve) {
		return false
	}
	if !this.QuickFailureThreshold.Equal(that1.QuickFailureThreshold) {
		return false
	}
	if !this.BinomTestP0.Equal(that1.BinomTestP0) {
		return false
	}
	return true
}
func (this *PoCModelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PoCModelParams)
	if !ok {
		that2, ok := that.(PoCModelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dim != that1.Dim {
		return false
	}
	if this.NLayers != that1.NLayers {
		return false
	}
	if this.NHeads != that1.NHeads {
		return false
	}
	if this.NKvHeads != that1.NKvHeads {
		return false
	}
	if this.VocabSize != that1.VocabSize {
		return false
	}
	if !this.FfnDimMultiplier.Equal(that1.FfnDimMultiplier) {
		return false
	}
	if this.MultipleOf != that1.MultipleOf {
		return false
	}
	if !this.NormEps.Equal(that1.NormEps) {
		return false
	}
	if this.RopeTheta != that1.RopeTheta {
		return false
	}
	if this.UseScaledRope != that1.UseScaledRope {
		return false
	}
	if this.SeqLen != that1.SeqLen {
		return false
	}
	if !this.RTarget.Equal(that1.RTarget) {
		return false
	}
	return true
}
func (this *PocParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PocParams)
	if !ok {
		that2, ok := that.(PocParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefaultDifficulty != that1.DefaultDifficulty {
		return false
	}
	if this.ValidationSampleSize != that1.ValidationSampleSize {
		return false
	}
	if this.PocDataPruningEpochThreshold != that1.PocDataPruningEpochThreshold {
		return false
	}
	if !this.WeightScaleFactor.Equal(that1.WeightScaleFactor) {
		return false
	}
	if !this.ModelParams.Equal(that1.ModelParams) {
		return false
	}
	return true
}
func (this *Decimal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Decimal)
	if !ok {
		that2, ok := that.(Decimal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Exponent != that1.Exponent {
		return false
	}
	return true
}
func (this *CollateralParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollateralParams)
	if !ok {
		that2, ok := that.(CollateralParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SlashFractionInvalid.Equal(that1.SlashFractionInvalid) {
		return false
	}
	if !this.SlashFractionDowntime.Equal(that1.SlashFractionDowntime) {
		return false
	}
	if !this.DowntimeMissedPercentageThreshold.Equal(that1.DowntimeMissedPercentageThreshold) {
		return false
	}
	if this.GracePeriodEndEpoch != that1.GracePeriodEndEpoch {
		return false
	}
	if !this.BaseWeightRatio.Equal(that1.BaseWeightRatio) {
		return false
	}
	if !this.CollateralPerWeightUnit.Equal(that1.CollateralPerWeightUnit) {
		return false
	}
	return true
}
func (this *BitcoinRewardParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BitcoinRewardParams)
	if !ok {
		that2, ok := that.(BitcoinRewardParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseBitcoinRewards != that1.UseBitcoinRewards {
		return false
	}
	if this.InitialEpochReward != that1.InitialEpochReward {
		return false
	}
	if !this.DecayRate.Equal(that1.DecayRate) {
		return false
	}
	if this.GenesisEpoch != that1.GenesisEpoch {
		return false
	}
	if !this.UtilizationBonusFactor.Equal(that1.UtilizationBonusFactor) {
		return false
	}
	if !this.FullCoverageBonusFactor.Equal(that1.FullCoverageBonusFactor) {
		return false
	}
	if !this.PartialCoverageBonusFactor.Equal(that1.PartialCoverageBonusFactor) {
		return false
	}
	return true
}
func (this *DynamicPricingParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DynamicPricingParams)
	if !ok {
		that2, ok := that.(DynamicPricingParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StabilityZoneLowerBound.Equal(that1.StabilityZoneLowerBound) {
		return false
	}
	if !this.StabilityZoneUpperBound.Equal(that1.StabilityZoneUpperBound) {
		return false
	}
	if !this.PriceElasticity.Equal(that1.PriceElasticity) {
		return false
	}
	if this.UtilizationWindowDuration != that1.UtilizationWindowDuration {
		return false
	}
	if this.MinPerTokenPrice != that1.MinPerTokenPrice {
		return false
	}
	if this.BasePerTokenPrice != that1.BasePerTokenPrice {
		return false
	}
	if this.GracePeriodEndEpoch != that1.GracePeriodEndEpoch {
		return false
	}
	if this.GracePeriodPerTokenPrice != that1.GracePeriodPerTokenPrice {
		return false
	}
	return true
}
func (this *BandwidthLimitsParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BandwidthLimitsParams)
	if !ok {
		that2, ok := that.(BandwidthLimitsParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EstimatedLimitsPerBlockKb != that1.EstimatedLimitsPerBlockKb {
		return false
	}
	if !this.KbPerInputToken.Equal(that1.KbPerInputToken) {
		return false
	}
	if !this.KbPerOutputToken.Equal(that1.KbPerOutputToken) {
		return false
	}
	if this.InvalidationsLimit != that1.InvalidationsLimit {
		return false
	}
	if this.InvalidationsSamplePeriod != that1.InvalidationsSamplePeriod {
		return false
	}
	if this.InvalidationsLimitCurve != that1.InvalidationsLimitCurve {
		return false
	}
	if this.MinimumConcurrentInvalidations != that1.MinimumConcurrentInvalidations {
		return false
	}
	if this.MaxInferencesPerBlock != that1.MaxInferencesPerBlock {
		return false
	}
	return true
}
func (this *ConfirmationPoCParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfirmationPoCParams)
	if !ok {
		that2, ok := that.(ConfirmationPoCParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpectedConfirmationsPerEpoch != that1.ExpectedConfirmationsPerEpoch {
		return false
	}
	if !this.AlphaThreshold.Equal(that1.AlphaThreshold) {
		return false
	}
	if !this.SlashFraction.Equal(that1.SlashFraction) {
		return false
	}
	if this.UpgradeProtectionWindow != that1.UpgradeProtectionWindow {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfirmationPocParams != nil {
		{
			size, err := m.ConfirmationPocParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.BandwidthLimitsParams != nil {
		{
			size, err := m.BandwidthLimitsParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DynamicPricingParams != nil {
		{
			size, err := m.DynamicPricingParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BitcoinRewardParams != nil {
		{
			size, err := m.BitcoinRewardParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CollateralParams != nil {
		{
			size, err := m.CollateralParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TokenomicsParams != nil {
		{
			size, err := m.TokenomicsParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PocParams != nil {
		{
			size, err := m.PocParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ValidationParams != nil {
		{
			size, err := m.ValidationParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EpochParams != nil {
		{
			size, err := m.EpochParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisOnlyParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisOnlyParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisOnlyParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GenesisGuardianAddresses) > 0 {
		for iNdEx := len(m.GenesisGuardianAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GenesisGuardianAddresses[iNdEx])
			copy(dAtA[i:], m.GenesisGuardianAddresses[iNdEx])
			i = encodeVarintParams(dAtA, i, uint64(len(m.GenesisGuardianAddresses[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.GenesisGuardianMultiplier != nil {
		{
			size, err := m.GenesisGuardianMultiplier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.GenesisGuardianNetworkMaturityThreshold != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.GenesisGuardianNetworkMaturityThreshold))
		i--
		dAtA[i] = 0x70
	}
	if m.GenesisGuardianEnabled {
		i--
		if m.GenesisGuardianEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.MaxIndividualPowerPercentage != nil {
		{
			size, err := m.MaxIndividualPowerPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.TopRewardMaxDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopRewardMaxDuration))
		i--
		dAtA[i] = 0x58
	}
	if m.TopRewardPayoutsPerMiner != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopRewardPayoutsPerMiner))
		i--
		dAtA[i] = 0x50
	}
	if m.TopRewardPayouts != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopRewardPayouts))
		i--
		dAtA[i] = 0x48
	}
	if m.TopRewardPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopRewardPeriod))
		i--
		dAtA[i] = 0x40
	}
	if len(m.SupplyDenom) > 0 {
		i -= len(m.SupplyDenom)
		copy(dAtA[i:], m.SupplyDenom)
		i = encodeVarintParams(dAtA, i, uint64(len(m.SupplyDenom)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TopRewards != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopRewards))
		i--
		dAtA[i] = 0x30
	}
	if m.PreProgrammedSaleAmount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PreProgrammedSaleAmount))
		i--
		dAtA[i] = 0x28
	}
	if m.StandardRewardAmount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.StandardRewardAmount))
		i--
		dAtA[i] = 0x20
	}
	if m.TopRewardAmount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopRewardAmount))
		i--
		dAtA[i] = 0x18
	}
	if m.OriginatorSupply != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.OriginatorSupply))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalSupply != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TotalSupply))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TokenomicsParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenomicsParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenomicsParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TopMinerVestingPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopMinerVestingPeriod))
		i--
		dAtA[i] = 0x40
	}
	if m.RewardVestingPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RewardVestingPeriod))
		i--
		dAtA[i] = 0x38
	}
	if m.WorkVestingPeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.WorkVestingPeriod))
		i--
		dAtA[i] = 0x30
	}
	if m.TopMinerPocQualification != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TopMinerPocQualification))
		i--
		dAtA[i] = 0x28
	}
	if m.TopRewardAllowedFailure != nil {
		{
			size, err := m.TopRewardAllowedFailure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CurrentSubsidyPercentage != nil {
		{
			size, err := m.CurrentSubsidyPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SubsidyReductionAmount != nil {
		{
			size, err := m.SubsidyReductionAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SubsidyReductionInterval != nil {
		{
			size, err := m.SubsidyReductionInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EpochParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PocSlotAllocation != nil {
		{
			size, err := m.PocSlotAllocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.PocPruningMax != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PocPruningMax))
		i--
		dAtA[i] = 0x68
	}
	if m.InferencePruningMax != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.InferencePruningMax))
		i--
		dAtA[i] = 0x60
	}
	if m.InferencePruningEpochThreshold != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.InferencePruningEpochThreshold))
		i--
		dAtA[i] = 0x58
	}
	if m.InferenceValidationCutoff != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.InferenceValidationCutoff))
		i--
		dAtA[i] = 0x50
	}
	if m.SetNewValidatorsDelay != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.SetNewValidatorsDelay))
		i--
		dAtA[i] = 0x48
	}
	if m.PocValidationDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PocValidationDuration))
		i--
		dAtA[i] = 0x40
	}
	if m.PocValidationDelay != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PocValidationDelay))
		i--
		dAtA[i] = 0x38
	}
	if m.PocExchangeDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PocExchangeDuration))
		i--
		dAtA[i] = 0x30
	}
	if m.PocStageDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PocStageDuration))
		i--
		dAtA[i] = 0x28
	}
	if m.DefaultUnitOfComputePrice != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DefaultUnitOfComputePrice))
		i--
		dAtA[i] = 0x20
	}
	if m.EpochShift != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EpochShift))
		i--
		dAtA[i] = 0x18
	}
	if m.EpochMultiplier != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EpochMultiplier))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EpochLength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidationParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidationParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidationParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BinomTestP0 != nil {
		{
			size, err := m.BinomTestP0.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.QuickFailureThreshold != nil {
		{
			size, err := m.QuickFailureThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.DowntimeReputationPreserve != nil {
		{
			size, err := m.DowntimeReputationPreserve.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.DowntimeHThreshold != nil {
		{
			size, err := m.DowntimeHThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.DowntimeBadPercentage != nil {
		{
			size, err := m.DowntimeBadPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.DowntimeGoodPercentage != nil {
		{
			size, err := m.DowntimeGoodPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.InvalidationHThreshold != nil {
		{
			size, err := m.InvalidationHThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.BadParticipantInvalidationRate != nil {
		{
			size, err := m.BadParticipantInvalidationRate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.InvalidReputationPreserve != nil {
		{
			size, err := m.InvalidReputationPreserve.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.EstimatedLimitsPerBlockKb != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EstimatedLimitsPerBlockKb))
		i--
		dAtA[i] = 0x78
	}
	if m.TimestampAdvance != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimestampAdvance))
		i--
		dAtA[i] = 0x70
	}
	if m.TimestampExpiration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimestampExpiration))
		i--
		dAtA[i] = 0x68
	}
	if m.MissRequestsPenalty != nil {
		{
			size, err := m.MissRequestsPenalty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MissPercentageCutoff != nil {
		{
			size, err := m.MissPercentageCutoff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MinValidationTrafficCutoff != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinValidationTrafficCutoff))
		i--
		dAtA[i] = 0x50
	}
	if m.MinValidationHalfway != nil {
		{
			size, err := m.MinValidationHalfway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.FullValidationTrafficCutoff != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.FullValidationTrafficCutoff))
		i--
		dAtA[i] = 0x40
	}
	if m.EpochsToMax != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EpochsToMax))
		i--
		dAtA[i] = 0x38
	}
	if m.ExpirationBlocks != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ExpirationBlocks))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxValidationAverage != nil {
		{
			size, err := m.MaxValidationAverage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MinValidationAverage != nil {
		{
			size, err := m.MinValidationAverage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PassValue != nil {
		{
			size, err := m.PassValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MinRampUpMeasurements != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinRampUpMeasurements))
		i--
		dAtA[i] = 0x10
	}
	if m.FalsePositiveRate != nil {
		{
			size, err := m.FalsePositiveRate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoCModelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoCModelParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoCModelParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RTarget != nil {
		{
			size, err := m.RTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SeqLen != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.SeqLen))
		i--
		dAtA[i] = 0x58
	}
	if m.UseScaledRope {
		i--
		if m.UseScaledRope {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RopeTheta != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.RopeTheta))
		i--
		dAtA[i] = 0x48
	}
	if m.NormEps != nil {
		{
			size, err := m.NormEps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.MultipleOf != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MultipleOf))
		i--
		dAtA[i] = 0x38
	}
	if m.FfnDimMultiplier != nil {
		{
			size, err := m.FfnDimMultiplier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.VocabSize != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.VocabSize))
		i--
		dAtA[i] = 0x28
	}
	if m.NKvHeads != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.NKvHeads))
		i--
		dAtA[i] = 0x20
	}
	if m.NHeads != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.NHeads))
		i--
		dAtA[i] = 0x18
	}
	if m.NLayers != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.NLayers))
		i--
		dAtA[i] = 0x10
	}
	if m.Dim != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.Dim))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PocParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PocParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PocParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelParams != nil {
		{
			size, err := m.ModelParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.WeightScaleFactor != nil {
		{
			size, err := m.WeightScaleFactor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PocDataPruningEpochThreshold != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.PocDataPruningEpochThreshold))
		i--
		dAtA[i] = 0x18
	}
	if m.ValidationSampleSize != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidationSampleSize))
		i--
		dAtA[i] = 0x10
	}
	if m.DefaultDifficulty != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DefaultDifficulty))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decimal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exponent != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x10
	}
	if m.Value != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollateralParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollateralParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollateralParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CollateralPerWeightUnit != nil {
		{
			size, err := m.CollateralPerWeightUnit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BaseWeightRatio != nil {
		{
			size, err := m.BaseWeightRatio.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.GracePeriodEndEpoch != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.GracePeriodEndEpoch))
		i--
		dAtA[i] = 0x20
	}
	if m.DowntimeMissedPercentageThreshold != nil {
		{
			size, err := m.DowntimeMissedPercentageThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashFractionDowntime != nil {
		{
			size, err := m.SlashFractionDowntime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SlashFractionInvalid != nil {
		{
			size, err := m.SlashFractionInvalid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BitcoinRewardParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BitcoinRewardParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BitcoinRewardParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PartialCoverageBonusFactor != nil {
		{
			size, err := m.PartialCoverageBonusFactor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.FullCoverageBonusFactor != nil {
		{
			size, err := m.FullCoverageBonusFactor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UtilizationBonusFactor != nil {
		{
			size, err := m.UtilizationBonusFactor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.GenesisEpoch != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.GenesisEpoch))
		i--
		dAtA[i] = 0x20
	}
	if m.DecayRate != nil {
		{
			size, err := m.DecayRate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InitialEpochReward != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.InitialEpochReward))
		i--
		dAtA[i] = 0x10
	}
	if m.UseBitcoinRewards {
		i--
		if m.UseBitcoinRewards {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DynamicPricingParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicPricingParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicPricingParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GracePeriodPerTokenPrice != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.GracePeriodPerTokenPrice))
		i--
		dAtA[i] = 0x40
	}
	if m.GracePeriodEndEpoch != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.GracePeriodEndEpoch))
		i--
		dAtA[i] = 0x38
	}
	if m.BasePerTokenPrice != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.BasePerTokenPrice))
		i--
		dAtA[i] = 0x30
	}
	if m.MinPerTokenPrice != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinPerTokenPrice))
		i--
		dAtA[i] = 0x28
	}
	if m.UtilizationWindowDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.UtilizationWindowDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.PriceElasticity != nil {
		{
			size, err := m.PriceElasticity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StabilityZoneUpperBound != nil {
		{
			size, err := m.StabilityZoneUpperBound.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StabilityZoneLowerBound != nil {
		{
			size, err := m.StabilityZoneLowerBound.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BandwidthLimitsParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BandwidthLimitsParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BandwidthLimitsParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxInferencesPerBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxInferencesPerBlock))
		i--
		dAtA[i] = 0x40
	}
	if m.MinimumConcurrentInvalidations != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinimumConcurrentInvalidations))
		i--
		dAtA[i] = 0x38
	}
	if m.InvalidationsLimitCurve != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.InvalidationsLimitCurve))
		i--
		dAtA[i] = 0x30
	}
	if m.InvalidationsSamplePeriod != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.InvalidationsSamplePeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.InvalidationsLimit != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.InvalidationsLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.KbPerOutputToken != nil {
		{
			size, err := m.KbPerOutputToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.KbPerInputToken != nil {
		{
			size, err := m.KbPerInputToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EstimatedLimitsPerBlockKb != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EstimatedLimitsPerBlockKb))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConfirmationPoCParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmationPoCParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfirmationPoCParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpgradeProtectionWindow != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.UpgradeProtectionWindow))
		i--
		dAtA[i] = 0x20
	}
	if m.SlashFraction != nil {
		{
			size, err := m.SlashFraction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AlphaThreshold != nil {
		{
			size, err := m.AlphaThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintParams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ExpectedConfirmationsPerEpoch != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ExpectedConfirmationsPerEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochParams != nil {
		l = m.EpochParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.ValidationParams != nil {
		l = m.ValidationParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.PocParams != nil {
		l = m.PocParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.TokenomicsParams != nil {
		l = m.TokenomicsParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.CollateralParams != nil {
		l = m.CollateralParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.BitcoinRewardParams != nil {
		l = m.BitcoinRewardParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.DynamicPricingParams != nil {
		l = m.DynamicPricingParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.BandwidthLimitsParams != nil {
		l = m.BandwidthLimitsParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.ConfirmationPocParams != nil {
		l = m.ConfirmationPocParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *GenesisOnlyParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalSupply != 0 {
		n += 1 + sovParams(uint64(m.TotalSupply))
	}
	if m.OriginatorSupply != 0 {
		n += 1 + sovParams(uint64(m.OriginatorSupply))
	}
	if m.TopRewardAmount != 0 {
		n += 1 + sovParams(uint64(m.TopRewardAmount))
	}
	if m.StandardRewardAmount != 0 {
		n += 1 + sovParams(uint64(m.StandardRewardAmount))
	}
	if m.PreProgrammedSaleAmount != 0 {
		n += 1 + sovParams(uint64(m.PreProgrammedSaleAmount))
	}
	if m.TopRewards != 0 {
		n += 1 + sovParams(uint64(m.TopRewards))
	}
	l = len(m.SupplyDenom)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	if m.TopRewardPeriod != 0 {
		n += 1 + sovParams(uint64(m.TopRewardPeriod))
	}
	if m.TopRewardPayouts != 0 {
		n += 1 + sovParams(uint64(m.TopRewardPayouts))
	}
	if m.TopRewardPayoutsPerMiner != 0 {
		n += 1 + sovParams(uint64(m.TopRewardPayoutsPerMiner))
	}
	if m.TopRewardMaxDuration != 0 {
		n += 1 + sovParams(uint64(m.TopRewardMaxDuration))
	}
	if m.MaxIndividualPowerPercentage != nil {
		l = m.MaxIndividualPowerPercentage.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.GenesisGuardianEnabled {
		n += 2
	}
	if m.GenesisGuardianNetworkMaturityThreshold != 0 {
		n += 1 + sovParams(uint64(m.GenesisGuardianNetworkMaturityThreshold))
	}
	if m.GenesisGuardianMultiplier != nil {
		l = m.GenesisGuardianMultiplier.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if len(m.GenesisGuardianAddresses) > 0 {
		for _, s := range m.GenesisGuardianAddresses {
			l = len(s)
			n += 2 + l + sovParams(uint64(l))
		}
	}
	return n
}

func (m *TokenomicsParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubsidyReductionInterval != nil {
		l = m.SubsidyReductionInterval.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.SubsidyReductionAmount != nil {
		l = m.SubsidyReductionAmount.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.CurrentSubsidyPercentage != nil {
		l = m.CurrentSubsidyPercentage.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.TopRewardAllowedFailure != nil {
		l = m.TopRewardAllowedFailure.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.TopMinerPocQualification != 0 {
		n += 1 + sovParams(uint64(m.TopMinerPocQualification))
	}
	if m.WorkVestingPeriod != 0 {
		n += 1 + sovParams(uint64(m.WorkVestingPeriod))
	}
	if m.RewardVestingPeriod != 0 {
		n += 1 + sovParams(uint64(m.RewardVestingPeriod))
	}
	if m.TopMinerVestingPeriod != 0 {
		n += 1 + sovParams(uint64(m.TopMinerVestingPeriod))
	}
	return n
}

func (m *EpochParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochLength != 0 {
		n += 1 + sovParams(uint64(m.EpochLength))
	}
	if m.EpochMultiplier != 0 {
		n += 1 + sovParams(uint64(m.EpochMultiplier))
	}
	if m.EpochShift != 0 {
		n += 1 + sovParams(uint64(m.EpochShift))
	}
	if m.DefaultUnitOfComputePrice != 0 {
		n += 1 + sovParams(uint64(m.DefaultUnitOfComputePrice))
	}
	if m.PocStageDuration != 0 {
		n += 1 + sovParams(uint64(m.PocStageDuration))
	}
	if m.PocExchangeDuration != 0 {
		n += 1 + sovParams(uint64(m.PocExchangeDuration))
	}
	if m.PocValidationDelay != 0 {
		n += 1 + sovParams(uint64(m.PocValidationDelay))
	}
	if m.PocValidationDuration != 0 {
		n += 1 + sovParams(uint64(m.PocValidationDuration))
	}
	if m.SetNewValidatorsDelay != 0 {
		n += 1 + sovParams(uint64(m.SetNewValidatorsDelay))
	}
	if m.InferenceValidationCutoff != 0 {
		n += 1 + sovParams(uint64(m.InferenceValidationCutoff))
	}
	if m.InferencePruningEpochThreshold != 0 {
		n += 1 + sovParams(uint64(m.InferencePruningEpochThreshold))
	}
	if m.InferencePruningMax != 0 {
		n += 1 + sovParams(uint64(m.InferencePruningMax))
	}
	if m.PocPruningMax != 0 {
		n += 1 + sovParams(uint64(m.PocPruningMax))
	}
	if m.PocSlotAllocation != nil {
		l = m.PocSlotAllocation.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *ValidationParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FalsePositiveRate != nil {
		l = m.FalsePositiveRate.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MinRampUpMeasurements != 0 {
		n += 1 + sovParams(uint64(m.MinRampUpMeasurements))
	}
	if m.PassValue != nil {
		l = m.PassValue.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MinValidationAverage != nil {
		l = m.MinValidationAverage.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MaxValidationAverage != nil {
		l = m.MaxValidationAverage.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.ExpirationBlocks != 0 {
		n += 1 + sovParams(uint64(m.ExpirationBlocks))
	}
	if m.EpochsToMax != 0 {
		n += 1 + sovParams(uint64(m.EpochsToMax))
	}
	if m.FullValidationTrafficCutoff != 0 {
		n += 1 + sovParams(uint64(m.FullValidationTrafficCutoff))
	}
	if m.MinValidationHalfway != nil {
		l = m.MinValidationHalfway.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MinValidationTrafficCutoff != 0 {
		n += 1 + sovParams(uint64(m.MinValidationTrafficCutoff))
	}
	if m.MissPercentageCutoff != nil {
		l = m.MissPercentageCutoff.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MissRequestsPenalty != nil {
		l = m.MissRequestsPenalty.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.TimestampExpiration != 0 {
		n += 1 + sovParams(uint64(m.TimestampExpiration))
	}
	if m.TimestampAdvance != 0 {
		n += 1 + sovParams(uint64(m.TimestampAdvance))
	}
	if m.EstimatedLimitsPerBlockKb != 0 {
		n += 1 + sovParams(uint64(m.EstimatedLimitsPerBlockKb))
	}
	if m.InvalidReputationPreserve != nil {
		l = m.InvalidReputationPreserve.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.BadParticipantInvalidationRate != nil {
		l = m.BadParticipantInvalidationRate.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.InvalidationHThreshold != nil {
		l = m.InvalidationHThreshold.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.DowntimeGoodPercentage != nil {
		l = m.DowntimeGoodPercentage.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.DowntimeBadPercentage != nil {
		l = m.DowntimeBadPercentage.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.DowntimeHThreshold != nil {
		l = m.DowntimeHThreshold.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.DowntimeReputationPreserve != nil {
		l = m.DowntimeReputationPreserve.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.QuickFailureThreshold != nil {
		l = m.QuickFailureThreshold.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	if m.BinomTestP0 != nil {
		l = m.BinomTestP0.Size()
		n += 2 + l + sovParams(uint64(l))
	}
	return n
}

func (m *PoCModelParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dim != 0 {
		n += 1 + sovParams(uint64(m.Dim))
	}
	if m.NLayers != 0 {
		n += 1 + sovParams(uint64(m.NLayers))
	}
	if m.NHeads != 0 {
		n += 1 + sovParams(uint64(m.NHeads))
	}
	if m.NKvHeads != 0 {
		n += 1 + sovParams(uint64(m.NKvHeads))
	}
	if m.VocabSize != 0 {
		n += 1 + sovParams(uint64(m.VocabSize))
	}
	if m.FfnDimMultiplier != nil {
		l = m.FfnDimMultiplier.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.MultipleOf != 0 {
		n += 1 + sovParams(uint64(m.MultipleOf))
	}
	if m.NormEps != nil {
		l = m.NormEps.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.RopeTheta != 0 {
		n += 1 + sovParams(uint64(m.RopeTheta))
	}
	if m.UseScaledRope {
		n += 2
	}
	if m.SeqLen != 0 {
		n += 1 + sovParams(uint64(m.SeqLen))
	}
	if m.RTarget != nil {
		l = m.RTarget.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *PocParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultDifficulty != 0 {
		n += 1 + sovParams(uint64(m.DefaultDifficulty))
	}
	if m.ValidationSampleSize != 0 {
		n += 1 + sovParams(uint64(m.ValidationSampleSize))
	}
	if m.PocDataPruningEpochThreshold != 0 {
		n += 1 + sovParams(uint64(m.PocDataPruningEpochThreshold))
	}
	if m.WeightScaleFactor != nil {
		l = m.WeightScaleFactor.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.ModelParams != nil {
		l = m.ModelParams.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *Decimal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovParams(uint64(m.Value))
	}
	if m.Exponent != 0 {
		n += 1 + sovParams(uint64(m.Exponent))
	}
	return n
}

func (m *CollateralParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SlashFractionInvalid != nil {
		l = m.SlashFractionInvalid.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.SlashFractionDowntime != nil {
		l = m.SlashFractionDowntime.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.DowntimeMissedPercentageThreshold != nil {
		l = m.DowntimeMissedPercentageThreshold.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.GracePeriodEndEpoch != 0 {
		n += 1 + sovParams(uint64(m.GracePeriodEndEpoch))
	}
	if m.BaseWeightRatio != nil {
		l = m.BaseWeightRatio.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.CollateralPerWeightUnit != nil {
		l = m.CollateralPerWeightUnit.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *BitcoinRewardParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseBitcoinRewards {
		n += 2
	}
	if m.InitialEpochReward != 0 {
		n += 1 + sovParams(uint64(m.InitialEpochReward))
	}
	if m.DecayRate != nil {
		l = m.DecayRate.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.GenesisEpoch != 0 {
		n += 1 + sovParams(uint64(m.GenesisEpoch))
	}
	if m.UtilizationBonusFactor != nil {
		l = m.UtilizationBonusFactor.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.FullCoverageBonusFactor != nil {
		l = m.FullCoverageBonusFactor.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.PartialCoverageBonusFactor != nil {
		l = m.PartialCoverageBonusFactor.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	return n
}

func (m *DynamicPricingParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StabilityZoneLowerBound != nil {
		l = m.StabilityZoneLowerBound.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.StabilityZoneUpperBound != nil {
		l = m.StabilityZoneUpperBound.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.PriceElasticity != nil {
		l = m.PriceElasticity.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.UtilizationWindowDuration != 0 {
		n += 1 + sovParams(uint64(m.UtilizationWindowDuration))
	}
	if m.MinPerTokenPrice != 0 {
		n += 1 + sovParams(uint64(m.MinPerTokenPrice))
	}
	if m.BasePerTokenPrice != 0 {
		n += 1 + sovParams(uint64(m.BasePerTokenPrice))
	}
	if m.GracePeriodEndEpoch != 0 {
		n += 1 + sovParams(uint64(m.GracePeriodEndEpoch))
	}
	if m.GracePeriodPerTokenPrice != 0 {
		n += 1 + sovParams(uint64(m.GracePeriodPerTokenPrice))
	}
	return n
}

func (m *BandwidthLimitsParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EstimatedLimitsPerBlockKb != 0 {
		n += 1 + sovParams(uint64(m.EstimatedLimitsPerBlockKb))
	}
	if m.KbPerInputToken != nil {
		l = m.KbPerInputToken.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.KbPerOutputToken != nil {
		l = m.KbPerOutputToken.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.InvalidationsLimit != 0 {
		n += 1 + sovParams(uint64(m.InvalidationsLimit))
	}
	if m.InvalidationsSamplePeriod != 0 {
		n += 1 + sovParams(uint64(m.InvalidationsSamplePeriod))
	}
	if m.InvalidationsLimitCurve != 0 {
		n += 1 + sovParams(uint64(m.InvalidationsLimitCurve))
	}
	if m.MinimumConcurrentInvalidations != 0 {
		n += 1 + sovParams(uint64(m.MinimumConcurrentInvalidations))
	}
	if m.MaxInferencesPerBlock != 0 {
		n += 1 + sovParams(uint64(m.MaxInferencesPerBlock))
	}
	return n
}

func (m *ConfirmationPoCParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpectedConfirmationsPerEpoch != 0 {
		n += 1 + sovParams(uint64(m.ExpectedConfirmationsPerEpoch))
	}
	if m.AlphaThreshold != nil {
		l = m.AlphaThreshold.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.SlashFraction != nil {
		l = m.SlashFraction.Size()
		n += 1 + l + sovParams(uint64(l))
	}
	if m.UpgradeProtectionWindow != 0 {
		n += 1 + sovParams(uint64(m.UpgradeProtectionWindow))
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EpochParams == nil {
				m.EpochParams = &EpochParams{}
			}
			if err := m.EpochParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidationParams == nil {
				m.ValidationParams = &ValidationParams{}
			}
			if err := m.ValidationParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PocParams == nil {
				m.PocParams = &PocParams{}
			}
			if err := m.PocParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenomicsParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenomicsParams == nil {
				m.TokenomicsParams = &TokenomicsParams{}
			}
			if err := m.TokenomicsParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollateralParams == nil {
				m.CollateralParams = &CollateralParams{}
			}
			if err := m.CollateralParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitcoinRewardParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BitcoinRewardParams == nil {
				m.BitcoinRewardParams = &BitcoinRewardParams{}
			}
			if err := m.BitcoinRewardParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicPricingParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicPricingParams == nil {
				m.DynamicPricingParams = &DynamicPricingParams{}
			}
			if err := m.DynamicPricingParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandwidthLimitsParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BandwidthLimitsParams == nil {
				m.BandwidthLimitsParams = &BandwidthLimitsParams{}
			}
			if err := m.BandwidthLimitsParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmationPocParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfirmationPocParams == nil {
				m.ConfirmationPocParams = &ConfirmationPoCParams{}
			}
			if err := m.ConfirmationPocParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisOnlyParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisOnlyParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisOnlyParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupply", wireType)
			}
			m.TotalSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSupply |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginatorSupply", wireType)
			}
			m.OriginatorSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginatorSupply |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopRewardAmount", wireType)
			}
			m.TopRewardAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopRewardAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardRewardAmount", wireType)
			}
			m.StandardRewardAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StandardRewardAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreProgrammedSaleAmount", wireType)
			}
			m.PreProgrammedSaleAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreProgrammedSaleAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopRewards", wireType)
			}
			m.TopRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopRewards |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopRewardPeriod", wireType)
			}
			m.TopRewardPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopRewardPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopRewardPayouts", wireType)
			}
			m.TopRewardPayouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopRewardPayouts |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopRewardPayoutsPerMiner", wireType)
			}
			m.TopRewardPayoutsPerMiner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopRewardPayoutsPerMiner |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopRewardMaxDuration", wireType)
			}
			m.TopRewardMaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopRewardMaxDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIndividualPowerPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxIndividualPowerPercentage == nil {
				m.MaxIndividualPowerPercentage = &Decimal{}
			}
			if err := m.MaxIndividualPowerPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisGuardianEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GenesisGuardianEnabled = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisGuardianNetworkMaturityThreshold", wireType)
			}
			m.GenesisGuardianNetworkMaturityThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisGuardianNetworkMaturityThreshold |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisGuardianMultiplier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GenesisGuardianMultiplier == nil {
				m.GenesisGuardianMultiplier = &Decimal{}
			}
			if err := m.GenesisGuardianMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisGuardianAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisGuardianAddresses = append(m.GenesisGuardianAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenomicsParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenomicsParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenomicsParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsidyReductionInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubsidyReductionInterval == nil {
				m.SubsidyReductionInterval = &Decimal{}
			}
			if err := m.SubsidyReductionInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsidyReductionAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubsidyReductionAmount == nil {
				m.SubsidyReductionAmount = &Decimal{}
			}
			if err := m.SubsidyReductionAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSubsidyPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentSubsidyPercentage == nil {
				m.CurrentSubsidyPercentage = &Decimal{}
			}
			if err := m.CurrentSubsidyPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopRewardAllowedFailure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopRewardAllowedFailure == nil {
				m.TopRewardAllowedFailure = &Decimal{}
			}
			if err := m.TopRewardAllowedFailure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMinerPocQualification", wireType)
			}
			m.TopMinerPocQualification = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMinerPocQualification |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkVestingPeriod", wireType)
			}
			m.WorkVestingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkVestingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardVestingPeriod", wireType)
			}
			m.RewardVestingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardVestingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMinerVestingPeriod", wireType)
			}
			m.TopMinerVestingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMinerVestingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochLength", wireType)
			}
			m.EpochLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochMultiplier", wireType)
			}
			m.EpochMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochMultiplier |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochShift", wireType)
			}
			m.EpochShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochShift |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUnitOfComputePrice", wireType)
			}
			m.DefaultUnitOfComputePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultUnitOfComputePrice |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocStageDuration", wireType)
			}
			m.PocStageDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PocStageDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocExchangeDuration", wireType)
			}
			m.PocExchangeDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PocExchangeDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocValidationDelay", wireType)
			}
			m.PocValidationDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PocValidationDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocValidationDuration", wireType)
			}
			m.PocValidationDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PocValidationDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetNewValidatorsDelay", wireType)
			}
			m.SetNewValidatorsDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetNewValidatorsDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferenceValidationCutoff", wireType)
			}
			m.InferenceValidationCutoff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InferenceValidationCutoff |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferencePruningEpochThreshold", wireType)
			}
			m.InferencePruningEpochThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InferencePruningEpochThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferencePruningMax", wireType)
			}
			m.InferencePruningMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InferencePruningMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocPruningMax", wireType)
			}
			m.PocPruningMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PocPruningMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocSlotAllocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PocSlotAllocation == nil {
				m.PocSlotAllocation = &Decimal{}
			}
			if err := m.PocSlotAllocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidationParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidationParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidationParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FalsePositiveRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FalsePositiveRate == nil {
				m.FalsePositiveRate = &Decimal{}
			}
			if err := m.FalsePositiveRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRampUpMeasurements", wireType)
			}
			m.MinRampUpMeasurements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinRampUpMeasurements |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassValue == nil {
				m.PassValue = &Decimal{}
			}
			if err := m.PassValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValidationAverage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinValidationAverage == nil {
				m.MinValidationAverage = &Decimal{}
			}
			if err := m.MinValidationAverage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValidationAverage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxValidationAverage == nil {
				m.MaxValidationAverage = &Decimal{}
			}
			if err := m.MaxValidationAverage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationBlocks", wireType)
			}
			m.ExpirationBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochsToMax", wireType)
			}
			m.EpochsToMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochsToMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullValidationTrafficCutoff", wireType)
			}
			m.FullValidationTrafficCutoff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullValidationTrafficCutoff |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValidationHalfway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinValidationHalfway == nil {
				m.MinValidationHalfway = &Decimal{}
			}
			if err := m.MinValidationHalfway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValidationTrafficCutoff", wireType)
			}
			m.MinValidationTrafficCutoff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValidationTrafficCutoff |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissPercentageCutoff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissPercentageCutoff == nil {
				m.MissPercentageCutoff = &Decimal{}
			}
			if err := m.MissPercentageCutoff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissRequestsPenalty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissRequestsPenalty == nil {
				m.MissRequestsPenalty = &Decimal{}
			}
			if err := m.MissRequestsPenalty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampExpiration", wireType)
			}
			m.TimestampExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampExpiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampAdvance", wireType)
			}
			m.TimestampAdvance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampAdvance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedLimitsPerBlockKb", wireType)
			}
			m.EstimatedLimitsPerBlockKb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedLimitsPerBlockKb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidReputationPreserve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvalidReputationPreserve == nil {
				m.InvalidReputationPreserve = &Decimal{}
			}
			if err := m.InvalidReputationPreserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadParticipantInvalidationRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadParticipantInvalidationRate == nil {
				m.BadParticipantInvalidationRate = &Decimal{}
			}
			if err := m.BadParticipantInvalidationRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidationHThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvalidationHThreshold == nil {
				m.InvalidationHThreshold = &Decimal{}
			}
			if err := m.InvalidationHThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DowntimeGoodPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DowntimeGoodPercentage == nil {
				m.DowntimeGoodPercentage = &Decimal{}
			}
			if err := m.DowntimeGoodPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DowntimeBadPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DowntimeBadPercentage == nil {
				m.DowntimeBadPercentage = &Decimal{}
			}
			if err := m.DowntimeBadPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DowntimeHThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DowntimeHThreshold == nil {
				m.DowntimeHThreshold = &Decimal{}
			}
			if err := m.DowntimeHThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DowntimeReputationPreserve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DowntimeReputationPreserve == nil {
				m.DowntimeReputationPreserve = &Decimal{}
			}
			if err := m.DowntimeReputationPreserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuickFailureThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuickFailureThreshold == nil {
				m.QuickFailureThreshold = &Decimal{}
			}
			if err := m.QuickFailureThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinomTestP0", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinomTestP0 == nil {
				m.BinomTestP0 = &Decimal{}
			}
			if err := m.BinomTestP0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoCModelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoCModelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoCModelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
			m.Dim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dim |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NLayers", wireType)
			}
			m.NLayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NLayers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NHeads", wireType)
			}
			m.NHeads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NHeads |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NKvHeads", wireType)
			}
			m.NKvHeads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NKvHeads |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VocabSize", wireType)
			}
			m.VocabSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VocabSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FfnDimMultiplier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FfnDimMultiplier == nil {
				m.FfnDimMultiplier = &Decimal{}
			}
			if err := m.FfnDimMultiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleOf", wireType)
			}
			m.MultipleOf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultipleOf |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormEps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NormEps == nil {
				m.NormEps = &Decimal{}
			}
			if err := m.NormEps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RopeTheta", wireType)
			}
			m.RopeTheta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RopeTheta |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseScaledRope", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseScaledRope = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqLen", wireType)
			}
			m.SeqLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RTarget == nil {
				m.RTarget = &Decimal{}
			}
			if err := m.RTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PocParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PocParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PocParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDifficulty", wireType)
			}
			m.DefaultDifficulty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultDifficulty |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationSampleSize", wireType)
			}
			m.ValidationSampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidationSampleSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PocDataPruningEpochThreshold", wireType)
			}
			m.PocDataPruningEpochThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PocDataPruningEpochThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightScaleFactor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WeightScaleFactor == nil {
				m.WeightScaleFactor = &Decimal{}
			}
			if err := m.WeightScaleFactor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelParams == nil {
				m.ModelParams = &PoCModelParams{}
			}
			if err := m.ModelParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decimal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decimal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollateralParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollateralParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollateralParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFractionInvalid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlashFractionInvalid == nil {
				m.SlashFractionInvalid = &Decimal{}
			}
			if err := m.SlashFractionInvalid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFractionDowntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlashFractionDowntime == nil {
				m.SlashFractionDowntime = &Decimal{}
			}
			if err := m.SlashFractionDowntime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DowntimeMissedPercentageThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DowntimeMissedPercentageThreshold == nil {
				m.DowntimeMissedPercentageThreshold = &Decimal{}
			}
			if err := m.DowntimeMissedPercentageThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriodEndEpoch", wireType)
			}
			m.GracePeriodEndEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriodEndEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseWeightRatio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseWeightRatio == nil {
				m.BaseWeightRatio = &Decimal{}
			}
			if err := m.BaseWeightRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralPerWeightUnit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollateralPerWeightUnit == nil {
				m.CollateralPerWeightUnit = &Decimal{}
			}
			if err := m.CollateralPerWeightUnit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BitcoinRewardParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BitcoinRewardParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BitcoinRewardParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseBitcoinRewards", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseBitcoinRewards = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialEpochReward", wireType)
			}
			m.InitialEpochReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialEpochReward |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecayRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecayRate == nil {
				m.DecayRate = &Decimal{}
			}
			if err := m.DecayRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisEpoch", wireType)
			}
			m.GenesisEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilizationBonusFactor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UtilizationBonusFactor == nil {
				m.UtilizationBonusFactor = &Decimal{}
			}
			if err := m.UtilizationBonusFactor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullCoverageBonusFactor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FullCoverageBonusFactor == nil {
				m.FullCoverageBonusFactor = &Decimal{}
			}
			if err := m.FullCoverageBonusFactor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialCoverageBonusFactor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartialCoverageBonusFactor == nil {
				m.PartialCoverageBonusFactor = &Decimal{}
			}
			if err := m.PartialCoverageBonusFactor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicPricingParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicPricingParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicPricingParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StabilityZoneLowerBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StabilityZoneLowerBound == nil {
				m.StabilityZoneLowerBound = &Decimal{}
			}
			if err := m.StabilityZoneLowerBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StabilityZoneUpperBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StabilityZoneUpperBound == nil {
				m.StabilityZoneUpperBound = &Decimal{}
			}
			if err := m.StabilityZoneUpperBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceElasticity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PriceElasticity == nil {
				m.PriceElasticity = &Decimal{}
			}
			if err := m.PriceElasticity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilizationWindowDuration", wireType)
			}
			m.UtilizationWindowDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UtilizationWindowDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPerTokenPrice", wireType)
			}
			m.MinPerTokenPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPerTokenPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePerTokenPrice", wireType)
			}
			m.BasePerTokenPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasePerTokenPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriodEndEpoch", wireType)
			}
			m.GracePeriodEndEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriodEndEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriodPerTokenPrice", wireType)
			}
			m.GracePeriodPerTokenPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriodPerTokenPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BandwidthLimitsParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BandwidthLimitsParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BandwidthLimitsParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedLimitsPerBlockKb", wireType)
			}
			m.EstimatedLimitsPerBlockKb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedLimitsPerBlockKb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbPerInputToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KbPerInputToken == nil {
				m.KbPerInputToken = &Decimal{}
			}
			if err := m.KbPerInputToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbPerOutputToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KbPerOutputToken == nil {
				m.KbPerOutputToken = &Decimal{}
			}
			if err := m.KbPerOutputToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidationsLimit", wireType)
			}
			m.InvalidationsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidationsLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidationsSamplePeriod", wireType)
			}
			m.InvalidationsSamplePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidationsSamplePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidationsLimitCurve", wireType)
			}
			m.InvalidationsLimitCurve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvalidationsLimitCurve |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumConcurrentInvalidations", wireType)
			}
			m.MinimumConcurrentInvalidations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumConcurrentInvalidations |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInferencesPerBlock", wireType)
			}
			m.MaxInferencesPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInferencesPerBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmationPoCParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmationPoCParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmationPoCParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedConfirmationsPerEpoch", wireType)
			}
			m.ExpectedConfirmationsPerEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedConfirmationsPerEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlphaThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlphaThreshold == nil {
				m.AlphaThreshold = &Decimal{}
			}
			if err := m.AlphaThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFraction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlashFraction == nil {
				m.SlashFraction = &Decimal{}
			}
			if err := m.SlashFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeProtectionWindow", wireType)
			}
			m.UpgradeProtectionWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeProtectionWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
